/* automatically generated by rust-bindgen 0.59.2 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CLINGO_VERSION_MAJOR: u32 = 5;
pub const CLINGO_VERSION_MINOR: u32 = 5;
pub const CLINGO_VERSION_REVISION: u32 = 1;
pub const CLINGO_VERSION: &[u8; 6usize] = b"5.5.1\0";
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "! Signed integer type used for aspif and solver literals."]
pub type clingo_literal_t = i32;
#[doc = "! Unsigned integer type used for aspif atoms."]
pub type clingo_atom_t = u32;
#[doc = "! Unsigned integer type used in various places."]
pub type clingo_id_t = u32;
#[doc = "! Signed integer type for weights in sum aggregates and minimize constraints."]
pub type clingo_weight_t = i32;
#[doc = "! A Literal with an associated weight."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_weighted_literal {
    pub literal: clingo_literal_t,
    pub weight: clingo_weight_t,
}
#[test]
fn bindgen_test_layout_clingo_weighted_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_weighted_literal>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_weighted_literal>(),
        4usize,
        concat!("Alignment of ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_weighted_literal>())).literal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_weighted_literal>())).weight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(weight)
        )
    );
}
#[doc = "! A Literal with an associated weight."]
pub type clingo_weighted_literal_t = clingo_weighted_literal;
#[doc = "!< successful API calls"]
pub const clingo_error_e_clingo_error_success: clingo_error_e = 0;
#[doc = "!< errors only detectable at runtime like invalid input"]
pub const clingo_error_e_clingo_error_runtime: clingo_error_e = 1;
#[doc = "!< wrong usage of the clingo API"]
pub const clingo_error_e_clingo_error_logic: clingo_error_e = 2;
#[doc = "!< memory could not be allocated"]
pub const clingo_error_e_clingo_error_bad_alloc: clingo_error_e = 3;
#[doc = "!< errors unrelated to clingo"]
pub const clingo_error_e_clingo_error_unknown: clingo_error_e = 4;
#[doc = "! Enumeration of error codes."]
#[doc = "!"]
#[doc = "! @note Errors can only be recovered from if explicitly mentioned; most"]
#[doc = "! functions do not provide strong exception guarantees.  This means that in"]
#[doc = "! case of errors associated objects cannot be used further.  If such an"]
#[doc = "! object has a free function, this function can and should still be called."]
pub type clingo_error_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_error_e."]
pub type clingo_error_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert error code into string."]
    pub fn clingo_error_string(code: clingo_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the last error code set by a clingo API call."]
    #[doc = "! @note Each thread has its own local error code."]
    #[doc = "! @return error code"]
    pub fn clingo_error_code() -> clingo_error_t;
}
extern "C" {
    #[doc = "! Get the last error message set if an API call fails."]
    #[doc = "! @note Each thread has its own local error message."]
    #[doc = "! @return error message or NULL"]
    pub fn clingo_error_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Set a custom error code and message in the active thread."]
    #[doc = "! @param[in] code the error code"]
    #[doc = "! @param[in] message the error message"]
    pub fn clingo_set_error(code: clingo_error_t, message: *const ::std::os::raw::c_char);
}
#[doc = "!< undefined arithmetic operation or weight of aggregate"]
pub const clingo_warning_e_clingo_warning_operation_undefined: clingo_warning_e = 0;
#[doc = "!< to report multiple errors; a corresponding runtime error is raised later"]
pub const clingo_warning_e_clingo_warning_runtime_error: clingo_warning_e = 1;
#[doc = "!< undefined atom in program"]
pub const clingo_warning_e_clingo_warning_atom_undefined: clingo_warning_e = 2;
#[doc = "!< same file included multiple times"]
pub const clingo_warning_e_clingo_warning_file_included: clingo_warning_e = 3;
#[doc = "!< CSP variable with unbounded domain"]
pub const clingo_warning_e_clingo_warning_variable_unbounded: clingo_warning_e = 4;
#[doc = "!< global variable in tuple of aggregate element"]
pub const clingo_warning_e_clingo_warning_global_variable: clingo_warning_e = 5;
#[doc = "!< other kinds of warnings"]
pub const clingo_warning_e_clingo_warning_other: clingo_warning_e = 6;
#[doc = "! Enumeration of warning codes."]
pub type clingo_warning_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_warning_e."]
pub type clingo_warning_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert warning code into string."]
    pub fn clingo_warning_string(code: clingo_warning_t) -> *const ::std::os::raw::c_char;
}
#[doc = "! Callback to intercept warning messages."]
#[doc = "!"]
#[doc = "! @param[in] code associated warning code"]
#[doc = "! @param[in] message warning message"]
#[doc = "! @param[in] data user data for callback"]
#[doc = "!"]
#[doc = "! @see clingo_control_new()"]
#[doc = "! @see clingo_parse_term()"]
#[doc = "! @see clingo_parse_program()"]
pub type clingo_logger_t = ::std::option::Option<
    unsafe extern "C" fn(
        code: clingo_warning_t,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "! Obtain the clingo version."]
    #[doc = "!"]
    #[doc = "! @param[out] major major version number"]
    #[doc = "! @param[out] minor minor version number"]
    #[doc = "! @param[out] revision revision number"]
    pub fn clingo_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        revision: *mut ::std::os::raw::c_int,
    );
}
#[doc = "!< no truth value"]
pub const clingo_truth_value_e_clingo_truth_value_free: clingo_truth_value_e = 0;
#[doc = "!< true"]
pub const clingo_truth_value_e_clingo_truth_value_true: clingo_truth_value_e = 1;
#[doc = "!< false"]
pub const clingo_truth_value_e_clingo_truth_value_false: clingo_truth_value_e = 2;
#[doc = "! Represents three-valued truth values."]
pub type clingo_truth_value_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_truth_value_e."]
pub type clingo_truth_value_t = ::std::os::raw::c_int;
#[doc = "! Represents a source code location marking its beginnig and end."]
#[doc = "!"]
#[doc = "! @note Not all locations refer to physical files."]
#[doc = "! By convention, such locations use a name put in angular brackets as filename."]
#[doc = "! The string members of a location object are internalized and valid for the duration of the process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_location {
    #[doc = "!< the file where the location begins"]
    pub begin_file: *const ::std::os::raw::c_char,
    #[doc = "!< the file where the location ends"]
    pub end_file: *const ::std::os::raw::c_char,
    #[doc = "!< the line where the location begins"]
    pub begin_line: usize,
    #[doc = "!< the line where the location ends"]
    pub end_line: usize,
    #[doc = "!< the column where the location begins"]
    pub begin_column: usize,
    #[doc = "!< the column where the location ends"]
    pub end_column: usize,
}
#[test]
fn bindgen_test_layout_clingo_location() {
    assert_eq!(
        ::std::mem::size_of::<clingo_location>(),
        48usize,
        concat!("Size of: ", stringify!(clingo_location))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_location>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_location))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_column as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_column as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_column)
        )
    );
}
#[doc = "! Represents a source code location marking its beginnig and end."]
#[doc = "!"]
#[doc = "! @note Not all locations refer to physical files."]
#[doc = "! By convention, such locations use a name put in angular brackets as filename."]
#[doc = "! The string members of a location object are internalized and valid for the duration of the process."]
pub type clingo_location_t = clingo_location;
#[doc = "! Represents a predicate signature."]
#[doc = "!"]
#[doc = "! Signatures have a name and an arity, and can be positive or negative (to"]
#[doc = "! represent classical negation)."]
pub type clingo_signature_t = u64;
extern "C" {
    #[doc = "! Create a new signature."]
    #[doc = "!"]
    #[doc = "! @param[in] name name of the signature"]
    #[doc = "! @param[in] arity arity of the signature"]
    #[doc = "! @param[in] positive false if the signature has a classical negation sign"]
    #[doc = "! @param[out] signature the resulting signature"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_signature_create(
        name: *const ::std::os::raw::c_char,
        arity: u32,
        positive: bool,
        signature: *mut clingo_signature_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a signature."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! The string is internalized and valid for the duration of the process."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the name of the signature"]
    pub fn clingo_signature_name(signature: clingo_signature_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the arity of a signature."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the arity of the signature"]
    pub fn clingo_signature_arity(signature: clingo_signature_t) -> u32;
}
extern "C" {
    #[doc = "! Whether the signature is positive (is not classically negated)."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return whether the signature has no sign"]
    pub fn clingo_signature_is_positive(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Whether the signature is negative (is classically negated)."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return whether the signature has a sign"]
    pub fn clingo_signature_is_negative(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if two signatures are equal."]
    #[doc = "!"]
    #[doc = "! @param[in] a first signature"]
    #[doc = "! @param[in] b second signature"]
    #[doc = "! @return whether a == b"]
    pub fn clingo_signature_is_equal_to(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a signature is less than another signature."]
    #[doc = "!"]
    #[doc = "! Signatures are compared first by sign (unsigned < signed), then by arity,"]
    #[doc = "! then by name."]
    #[doc = "!"]
    #[doc = "! @param[in] a first signature"]
    #[doc = "! @param[in] b second signature"]
    #[doc = "! @return whether a < b"]
    pub fn clingo_signature_is_less_than(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a signature."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the hash code of the signature"]
    pub fn clingo_signature_hash(signature: clingo_signature_t) -> usize;
}
#[doc = "!< the <tt>\\#inf</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_infimum: clingo_symbol_type_e = 0;
#[doc = "!< a numeric symbol, e.g., `1`"]
pub const clingo_symbol_type_e_clingo_symbol_type_number: clingo_symbol_type_e = 1;
#[doc = "!< a string symbol, e.g., `\"a\"`"]
pub const clingo_symbol_type_e_clingo_symbol_type_string: clingo_symbol_type_e = 4;
#[doc = "!< a numeric symbol, e.g., `c`, `(1, \"a\")`, or `f(1,\"a\")`"]
pub const clingo_symbol_type_e_clingo_symbol_type_function: clingo_symbol_type_e = 5;
#[doc = "!< the <tt>\\#sup</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_supremum: clingo_symbol_type_e = 7;
#[doc = "! Enumeration of available symbol types."]
pub type clingo_symbol_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_symbol_type."]
pub type clingo_symbol_type_t = ::std::os::raw::c_int;
#[doc = "! Represents a symbol."]
#[doc = "!"]
#[doc = "! This includes numbers, strings, functions (including constants when"]
#[doc = "! arguments are empty and tuples when the name is empty), <tt>\\#inf</tt> and <tt>\\#sup</tt>."]
pub type clingo_symbol_t = u64;
extern "C" {
    #[doc = "! Construct a symbol representing a number."]
    #[doc = "!"]
    #[doc = "! @param[in] number the number"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_number(number: ::std::os::raw::c_int, symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing \\#sup."]
    #[doc = "!"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_supremum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing <tt>\\#inf</tt>."]
    #[doc = "!"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_infimum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing a string."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_string(
        string: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing an id."]
    #[doc = "!"]
    #[doc = "! @note This is just a shortcut for clingo_symbol_create_function() with"]
    #[doc = "! empty arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name"]
    #[doc = "! @param[in] positive whether the symbol has a classical negation sign"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_id(
        name: *const ::std::os::raw::c_char,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing a function or tuple."]
    #[doc = "!"]
    #[doc = "! @note To create tuples, the empty string has to be used as name."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name of the function"]
    #[doc = "! @param[in] arguments the arguments of the function"]
    #[doc = "! @param[in] arguments_size the number of arguments"]
    #[doc = "! @param[in] positive whether the symbol has a classical negation sign"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_function(
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] number the resulting number"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_number"]
    pub fn clingo_symbol_number(
        symbol: clingo_symbol_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a symbol."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! The string is internalized and valid for the duration of the process."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_name(
        symbol: clingo_symbol_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string of a symbol."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! The string is internalized and valid for the duration of the process."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_string"]
    pub fn clingo_symbol_string(
        symbol: clingo_symbol_t,
        string: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is positive (does not have a sign)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] positive the result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_positive(symbol: clingo_symbol_t, positive: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is negative (has a sign)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] negative the result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_negative(symbol: clingo_symbol_t, negative: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] arguments the resulting arguments"]
    #[doc = "! @param[out] arguments_size the number of arguments"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_arguments(
        symbol: clingo_symbol_t,
        arguments: *mut *const clingo_symbol_t,
        arguments_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @return the type of the symbol"]
    pub fn clingo_symbol_type(symbol: clingo_symbol_t) -> clingo_symbol_type_t;
}
extern "C" {
    #[doc = "! Get the size of the string representation of a symbol (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_to_string_size(symbol: clingo_symbol_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "!"]
    #[doc = "! @see clingo_symbol_to_string_size()"]
    pub fn clingo_symbol_to_string(
        symbol: clingo_symbol_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two symbols are equal."]
    #[doc = "!"]
    #[doc = "! @param[in] a first symbol"]
    #[doc = "! @param[in] b second symbol"]
    #[doc = "! @return whether a == b"]
    pub fn clingo_symbol_is_equal_to(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a symbol is less than another symbol."]
    #[doc = "!"]
    #[doc = "! Symbols are first compared by type.  If the types are equal, the values are"]
    #[doc = "! compared (where strings are compared using strcmp).  Functions are first"]
    #[doc = "! compared by signature and then lexicographically by arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] a first symbol"]
    #[doc = "! @param[in] b second symbol"]
    #[doc = "! @return whether a < b"]
    pub fn clingo_symbol_is_less_than(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @return the hash code of the symbol"]
    pub fn clingo_symbol_hash(symbol: clingo_symbol_t) -> usize;
}
extern "C" {
    #[doc = "! Internalize a string."]
    #[doc = "!"]
    #[doc = "! This functions takes a string as input and returns an equal unique string"]
    #[doc = "! that is (at the moment) not freed until the program is closed."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string to internalize"]
    #[doc = "! @param[out] result the internalized string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_add_string(
        string: *const ::std::os::raw::c_char,
        result: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Parse a term in string form."]
    #[doc = "!"]
    #[doc = "! The result of this function is a symbol. The input term can contain"]
    #[doc = "! unevaluated functions, which are evaluated during parsing."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string to parse"]
    #[doc = "! @param[in] logger optional logger to report warnings during parsing"]
    #[doc = "! @param[in] logger_data user data for the logger"]
    #[doc = "! @param[in] message_limit maximum number of times to call the logger"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_parse_term(
        string: *const ::std::os::raw::c_char,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_symbolic_atoms {
    _unused: [u8; 0],
}
#[doc = "! Object to inspect symbolic atoms in a program---the relevant Herbrand base"]
#[doc = "! gringo uses to instantiate programs."]
#[doc = "!"]
#[doc = "! @see clingo_control_symbolic_atoms()"]
pub type clingo_symbolic_atoms_t = clingo_symbolic_atoms;
#[doc = "! Object to iterate over symbolic atoms."]
#[doc = "!"]
#[doc = "! Such an iterator either points to a symbolic atom within a sequence of"]
#[doc = "! symbolic atoms or to the end of the sequence."]
#[doc = "!"]
#[doc = "! @note Iterators are valid as long as the underlying sequence is not modified."]
#[doc = "! Operations that can change this sequence are ::clingo_control_ground(),"]
#[doc = "! ::clingo_control_cleanup(), and functions that modify the underlying"]
#[doc = "! non-ground program."]
pub type clingo_symbolic_atom_iterator_t = u64;
extern "C" {
    #[doc = "! Get the number of different atoms occurring in a logic program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the number of atoms"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a forward iterator to the beginning of the sequence of all symbolic"]
    #[doc = "! atoms optionally restricted to a given signature."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] signature optional signature"]
    #[doc = "! @param[out] iterator the resulting iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_begin(
        atoms: *const clingo_symbolic_atoms_t,
        signature: *const clingo_signature_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Iterator pointing to the end of the sequence of symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] iterator the resulting iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_end(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Find a symbolic atom given its symbolic representation."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] symbol the symbol to lookup"]
    #[doc = "! @param[out] iterator iterator pointing to the symbolic atom or to the end"]
    #[doc = "! of the sequence if no corresponding atom is found"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_find(
        atoms: *const clingo_symbolic_atoms_t,
        symbol: clingo_symbol_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two iterators point to the same element (or end of the sequence)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] a the first iterator"]
    #[doc = "! @param[in] b the second iterator"]
    #[doc = "! @param[out] equal whether the two iterators are equal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_iterator_is_equal_to(
        atoms: *const clingo_symbolic_atoms_t,
        a: clingo_symbolic_atom_iterator_t,
        b: clingo_symbolic_atom_iterator_t,
        equal: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbolic representation of an atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_symbol(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is a fact."]
    #[doc = "!"]
    #[doc = "! @note This does not determine if an atom is a cautious consequence. The"]
    #[doc = "! grounding or solving component's simplifications can only detect this in"]
    #[doc = "! some cases."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] fact whether the atom is a fact"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_fact(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        fact: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is external."]
    #[doc = "!"]
    #[doc = "! An atom is external if it has been defined using an external directive and"]
    #[doc = "! has not been released or defined by a rule."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] external whether the atom is a external"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_external(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        external: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the (numeric) aspif literal corresponding to the given symbolic atom."]
    #[doc = "!"]
    #[doc = "! Such a literal can be mapped to a solver literal (see the \\ref Propagator"]
    #[doc = "! module) or be used in rules in aspif format (see the \\ref ProgramBuilder"]
    #[doc = "! module)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] literal the associated literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_literal(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of different predicate signatures used in the program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the number of signatures"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_signatures_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the predicate signatures occurring in a logic program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] signatures the resulting signatures"]
    #[doc = "! @param[in] size the number of signatures"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_symbolic_atoms_signatures_size()"]
    pub fn clingo_symbolic_atoms_signatures(
        atoms: *const clingo_symbolic_atoms_t,
        signatures: *mut clingo_signature_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an iterator to the next element in the sequence of symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator the current iterator"]
    #[doc = "! @param[out] next the succeeding iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_next(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        next: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether the given iterator points to some element with the sequence"]
    #[doc = "! of symbolic atoms or to the end of the sequence."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator the iterator"]
    #[doc = "! @param[out] valid whether the iterator points to some element within the"]
    #[doc = "! sequence"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_valid(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        valid: *mut bool,
    ) -> bool;
}
#[doc = "! Callback function to inject symbols."]
#[doc = "!"]
#[doc = "! @param symbols array of symbols"]
#[doc = "! @param symbols_size size of the symbol array"]
#[doc = "! @param data user data of the callback"]
#[doc = "! @return whether the call was successful; might set one of the following error codes:"]
#[doc = "! - ::clingo_error_bad_alloc"]
#[doc = "! @see ::clingo_ground_callback_t"]
pub type clingo_symbol_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        symbols: *const clingo_symbol_t,
        symbols_size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "!< a tuple term, e.g., `(1,2,3)`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_tuple: clingo_theory_term_type_e = 0;
#[doc = "!< a list term, e.g., `[1,2,3]`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_list: clingo_theory_term_type_e = 1;
#[doc = "!< a set term, e.g., `{1,2,3}`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_set: clingo_theory_term_type_e = 2;
#[doc = "!< a function term, e.g., `f(1,2,3)`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_function: clingo_theory_term_type_e = 3;
#[doc = "!< a number term, e.g., `42`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_number: clingo_theory_term_type_e = 4;
#[doc = "!< a symbol term, e.g., `c`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_symbol: clingo_theory_term_type_e = 5;
#[doc = "! Enumeration of theory term types."]
pub type clingo_theory_term_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_theory_term_type_e."]
pub type clingo_theory_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_theory_atoms {
    _unused: [u8; 0],
}
#[doc = "! Container that stores theory atoms, elements, and terms (see @ref clingo_control_theory_atoms())."]
pub type clingo_theory_atoms_t = clingo_theory_atoms;
extern "C" {
    #[doc = "! Get the type of the given theory term."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_type(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        type_: *mut clingo_theory_term_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of the given numeric theory term."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_number."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] number the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_number(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of the given constant or function theory term."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! The lifetime of the string is tied to the current solve step."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_function or ::clingo_theory_term_type_symbol."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_name(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of the given function theory term."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_function."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] arguments the resulting arguments in form of an array of term ids"]
    #[doc = "! @param[out] size the number of arguments"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_arguments(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        arguments: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory term (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_term_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory term."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "!"]
    #[doc = "! @see clingo_theory_atoms_term_to_string_size()"]
    pub fn clingo_theory_atoms_term_to_string(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the tuple (array of theory terms) of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] tuple the resulting array of term ids"]
    #[doc = "! @param[out] size the number of term ids"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_tuple(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        tuple: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the condition (array of aspif literals) of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] condition the resulting array of aspif literals"]
    #[doc = "! @param[out] size the number of term literals"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the condition of the given theory element."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! This id can be mapped to a solver literal using clingo_propagate_init_solver_literal()."]
    #[doc = "! This id is not (necessarily) an aspif literal;"]
    #[doc = "! to get aspif literals use clingo_theory_atoms_element_condition()."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] condition the resulting condition id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition_id(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory element (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the total number of theory atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_size(atoms: *const clingo_theory_atoms_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the theory term associated with the theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] term the resulting term id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_term(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the theory elements associated with the theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] elements the resulting array of elements"]
    #[doc = "! @param[out] size the number of elements"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_elements(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        elements: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Whether the theory atom has a guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] has_guard whether the theory atom has a guard"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_has_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        has_guard: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the guard consisting of a theory operator and a theory term of the given theory atom."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! The lifetime of the string is tied to the current solve step."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] connective the resulting theory operator"]
    #[doc = "! @param[out] term the resulting term"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        connective: *mut *const ::std::os::raw::c_char,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the aspif literal associated with the given theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] literal the resulting literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_literal(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory atom (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the element"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the element"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_assignment {
    _unused: [u8; 0],
}
#[doc = "! Represents a (partial) assignment of a particular solver."]
#[doc = "!"]
#[doc = "! An assignment assigns truth values to a set of literals."]
#[doc = "! A literal is assigned to either @link clingo_assignment_truth_value() true or false, or is unassigned@endlink."]
#[doc = "! Furthermore, each assigned literal is associated with a @link clingo_assignment_level() decision level@endlink."]
#[doc = "! There is exactly one @link clingo_assignment_decision() decision literal@endlink for each decision level greater than zero."]
#[doc = "! Assignments to all other literals on the same level are consequences implied by the current and possibly previous decisions."]
#[doc = "! Assignments on level zero are immediate consequences of the current program."]
#[doc = "! Decision levels are consecutive numbers starting with zero up to and including the @link clingo_assignment_decision_level() current decision level@endlink."]
pub type clingo_assignment_t = clingo_assignment;
extern "C" {
    #[doc = "! Get the current decision level."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return the decision level"]
    pub fn clingo_assignment_decision_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Get the current root level."]
    #[doc = "!"]
    #[doc = "! Decisions levels smaller or equal to the root level are not backtracked during solving."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return the decision level"]
    pub fn clingo_assignment_root_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Check if the given assignment is conflicting."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return whether the assignment is conflicting"]
    pub fn clingo_assignment_has_conflict(assignment: *const clingo_assignment_t) -> bool;
}
extern "C" {
    #[doc = "! Check if the given literal is part of a (partial) assignment."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @return whether the literal is valid"]
    pub fn clingo_assignment_has_literal(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision level of a given literal."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] level the resulting level"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_level(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        level: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision literal given a decision level."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] level the level"]
    #[doc = "! @param[out] literal the resulting literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_decision(
        assignment: *const clingo_assignment_t,
        level: u32,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_fixed whether the literal is fixed"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_is_fixed(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_fixed: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal is true."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_true whether the literal is true"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_true(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_true: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_false whether the literal is false"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_false(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_false: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the truth value of a given literal."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] value the resulting truth value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_truth_value(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        value: *mut clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! The number of (positive) literals in the assignment."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @return the number of literals"]
    pub fn clingo_assignment_size(assignment: *const clingo_assignment_t) -> usize;
}
extern "C" {
    #[doc = "! The (positive) literal at the given offset in the assignment."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @param[in] offset the offset of the literal"]
    #[doc = "! @param[out] literal the literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_at(
        assignment: *const clingo_assignment_t,
        offset: usize,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the assignment is total, i.e. there are no free literal."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @return wheather the assignment is total"]
    pub fn clingo_assignment_is_total(assignment: *const clingo_assignment_t) -> bool;
}
extern "C" {
    #[doc = "! Returns the number of literals in the trail, i.e., the number of assigned literals."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @param[out] size the number of literals in the trail"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_trail_size(
        assignment: *const clingo_assignment_t,
        size: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the offset of the decision literal with the given decision level in"]
    #[doc = "! the trail."]
    #[doc = "!"]
    #[doc = "! @note Literals in the trail are ordered by decision levels, where the first"]
    #[doc = "! literal with a larger level than the previous literals is a decision; the"]
    #[doc = "! following literals with same level are implied by this decision literal."]
    #[doc = "! Each decision level up to and including the current decision level has a"]
    #[doc = "! valid offset in the trail."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @param[in] level the decision level"]
    #[doc = "! @param[out] offset the offset of the decision literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_trail_begin(
        assignment: *const clingo_assignment_t,
        level: u32,
        offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the offset following the last literal with the given decision level."]
    #[doc = "!"]
    #[doc = "! @note This function is the counter part to clingo_assignment_trail_begin()."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @param[in] level the decision level"]
    #[doc = "! @param[out] offset the offset"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_trail_end(
        assignment: *const clingo_assignment_t,
        level: u32,
        offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the literal at the given position in the trail."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @param[in] offset the offset of the literal"]
    #[doc = "! @param[out] literal the literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_trail_at(
        assignment: *const clingo_assignment_t,
        offset: u32,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
#[doc = "!< do not call @ref ::clingo_propagator::check() at all"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_none:
    clingo_propagator_check_mode_e = 0;
#[doc = "!< call @ref ::clingo_propagator::check() on total assignments"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_total:
    clingo_propagator_check_mode_e = 1;
#[doc = "!< call @ref ::clingo_propagator::check() on propagation fixpoints"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_fixpoint:
    clingo_propagator_check_mode_e = 2;
#[doc = "!< call @ref ::clingo_propagator::check() on propagation fixpoints and total assignments"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_both:
    clingo_propagator_check_mode_e = 3;
#[doc = "! Supported check modes for propagators."]
#[doc = "!"]
#[doc = "! Note that total checks are subject to the lock when a model is found."]
#[doc = "! This means that information from previously found models can be used to discard assignments in check calls."]
pub type clingo_propagator_check_mode_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_propagator_check_mode_e."]
pub type clingo_propagator_check_mode_t = ::std::os::raw::c_int;
#[doc = "!< the weight constraint implies the literal"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_implication_left:
    clingo_weight_constraint_type_e = -1;
#[doc = "!< the literal implies the weight constraint"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_implication_right:
    clingo_weight_constraint_type_e = 1;
#[doc = "!< the weight constraint is equivalent to the literal"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_equivalence:
    clingo_weight_constraint_type_e = 0;
#[doc = "! Enumeration of weight_constraint_types."]
pub type clingo_weight_constraint_type_e = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_weight_constraint_type_e."]
pub type clingo_weight_constraint_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_init {
    _unused: [u8; 0],
}
#[doc = "! Object to initialize a user-defined propagator before each solving step."]
#[doc = "!"]
#[doc = "! Each @link SymbolicAtoms symbolic@endlink or @link TheoryAtoms theory atom@endlink is uniquely associated with an aspif atom in form of a positive integer (@ref ::clingo_literal_t)."]
#[doc = "! Aspif literals additionally are signed to represent default negation."]
#[doc = "! Furthermore, there are non-zero integer solver literals (also represented using @ref ::clingo_literal_t)."]
#[doc = "! There is a surjective mapping from program atoms to solver literals."]
#[doc = "!"]
#[doc = "! All methods called during propagation use solver literals whereas clingo_symbolic_atoms_literal() and clingo_theory_atoms_atom_literal() return program literals."]
#[doc = "! The function clingo_propagate_init_solver_literal() can be used to map program literals or @link clingo_theory_atoms_element_condition_id() condition ids@endlink to solver literals."]
pub type clingo_propagate_init_t = clingo_propagate_init;
extern "C" {
    #[doc = "! Map the given program literal or condition id to its solver literal."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] aspif_literal the aspif literal to map"]
    #[doc = "! @param[out] solver_literal the resulting solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_solver_literal(
        init: *const clingo_propagate_init_t,
        aspif_literal: clingo_literal_t,
        solver_literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase to the given solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @param[in] thread_id the id of the solver thread"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch_to_thread(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
        thread_id: clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove the watch for the solver literal in the given phase."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_remove_watch(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove the watch for the solver literal in the given phase from the given solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @param[in] thread_id the id of the solver thread"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_remove_watch_from_thread(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
        thread_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Freeze the given solver literal."]
    #[doc = "!"]
    #[doc = "! Any solver literal that is not frozen is subject to simplification and might be removed in a preprocessing step after propagator initialization."]
    #[doc = "! A propagator should freeze all literals over which it might add clauses during propagation."]
    #[doc = "! Note that any watched literal is automatically frozen and that it does not matter which phase of the literal is frozen."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_freeze_literal(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_symbolic_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the theory atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_theory_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of threads used in subsequent solving."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return the number of threads"]
    #[doc = "! @see clingo_propagate_control_thread_id()"]
    pub fn clingo_propagate_init_number_of_threads(
        init: *const clingo_propagate_init_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! Configure when to call the check method of the propagator."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] mode bitmask when to call the propagator"]
    #[doc = "! @see @ref ::clingo_propagator::check()"]
    pub fn clingo_propagate_init_set_check_mode(
        init: *mut clingo_propagate_init_t,
        mode: clingo_propagator_check_mode_t,
    );
}
extern "C" {
    #[doc = "! Get the current check mode of the propagator."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return bitmask when to call the propagator"]
    #[doc = "! @see clingo_propagate_init_set_check_mode()"]
    pub fn clingo_propagate_init_get_check_mode(
        init: *const clingo_propagate_init_t,
    ) -> clingo_propagator_check_mode_t;
}
extern "C" {
    #[doc = "! Get the top level assignment solver."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return the assignment"]
    pub fn clingo_propagate_init_assignment(
        init: *const clingo_propagate_init_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Add a literal to the solver."]
    #[doc = "!"]
    #[doc = "! To be able to use the variable in clauses during propagation or add watches to it, it has to be frozen."]
    #[doc = "! Otherwise, it might be removed during preprocessing."]
    #[doc = "!"]
    #[doc = "! @attention If varibales were added, subsequent calls to functions adding constraints or ::clingo_propagate_init_propagate() are expensive."]
    #[doc = "! It is best to add varables in batches."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] freeze whether to freeze the literal"]
    #[doc = "! @param[out] result the added literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_literal(
        init: *mut clingo_propagate_init_t,
        freeze: bool,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given clause to the solver."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] clause the clause to add"]
    #[doc = "! @param[in] size the size of the clause"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_clause(
        init: *mut clingo_propagate_init_t,
        clause: *const clingo_literal_t,
        size: usize,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given weight constraint to the solver."]
    #[doc = "!"]
    #[doc = "! This function adds a constraint of form `literal <=> { lit=weight | (lit, weight) in literals } >= bound` to the solver."]
    #[doc = "! Depending on the type the `<=>` connective can be either a left implication, right implication, or equivalence."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] literal the literal of the constraint"]
    #[doc = "! @param[in] literals the weighted literals"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @param[in] bound the bound of the constraint"]
    #[doc = "! @param[in] type the type of the weight constraint"]
    #[doc = "! @param[in] compare_equal if true compare equal instead of less than equal"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_weight_constraint(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
        bound: clingo_weight_t,
        type_: clingo_weight_constraint_type_t,
        compare_equal: bool,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given literal to minimize to the solver."]
    #[doc = "!"]
    #[doc = "! This corresponds to a weak constraint of form `:~ literal. [weight@priority]`."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] literal the literal to minimize"]
    #[doc = "! @param[in] weight the weight of the literal"]
    #[doc = "! @param[in] priority the priority of the literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_minimize(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        weight: clingo_weight_t,
        priority: clingo_weight_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagates consequences of the underlying problem excluding registered propagators."]
    #[doc = "!"]
    #[doc = "! @note The function has no effect if SAT-preprocessing is enabled."]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_propagate(
        init: *mut clingo_propagate_init_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "!< clause is subject to the solvers deletion policy"]
pub const clingo_clause_type_e_clingo_clause_type_learnt: clingo_clause_type_e = 0;
#[doc = "!< clause is not subject to the solvers deletion policy"]
pub const clingo_clause_type_e_clingo_clause_type_static: clingo_clause_type_e = 1;
#[doc = "!< like ::clingo_clause_type_learnt but the clause is deleted after a solving step"]
pub const clingo_clause_type_e_clingo_clause_type_volatile: clingo_clause_type_e = 2;
#[doc = "!< like ::clingo_clause_type_static but the clause is deleted after a solving step"]
pub const clingo_clause_type_e_clingo_clause_type_volatile_static: clingo_clause_type_e = 3;
#[doc = "! Enumeration of clause types determining the lifetime of a clause."]
#[doc = "!"]
#[doc = "! Clauses in the solver are either cleaned up based on a configurable deletion policy or at the end of a solving step."]
#[doc = "! The values of this enumeration determine if a clause is subject to one of the above deletion strategies."]
pub type clingo_clause_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_clause_type_e."]
pub type clingo_clause_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_control {
    _unused: [u8; 0],
}
#[doc = "! This object can be used to add clauses and propagate literals while solving."]
pub type clingo_propagate_control_t = clingo_propagate_control;
extern "C" {
    #[doc = "! Get the id of the underlying solver thread."]
    #[doc = "!"]
    #[doc = "! Thread ids are consecutive numbers starting with zero."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return the thread id"]
    pub fn clingo_propagate_control_thread_id(
        control: *const clingo_propagate_control_t,
    ) -> clingo_id_t;
}
extern "C" {
    #[doc = "! Get the assignment associated with the underlying solver."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return the assignment"]
    pub fn clingo_propagate_control_assignment(
        control: *const clingo_propagate_control_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Adds a new volatile literal to the underlying solver thread."]
    #[doc = "!"]
    #[doc = "! @attention The literal is only valid within the current solving step and solver thread."]
    #[doc = "! All volatile literals and clauses involving a volatile literal are deleted after the current search."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] result the (positive) solver literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_logic if the assignment is conflicting"]
    pub fn clingo_propagate_control_add_literal(
        control: *mut clingo_propagate_control_t,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase."]
    #[doc = "!"]
    #[doc = "! @note Unlike @ref clingo_propagate_init_add_watch() this does not add a watch to all solver threads but just the current one."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to watch"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_logic if the literal is invalid"]
    #[doc = "! @see clingo_propagate_control_remove_watch()"]
    pub fn clingo_propagate_control_add_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a literal is watched in the current solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to check"]
    #[doc = "!"]
    #[doc = "! @return whether the literal is watched"]
    pub fn clingo_propagate_control_has_watch(
        control: *const clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Removes the watch (if any) for the given solver literal."]
    #[doc = "!"]
    #[doc = "! @note Similar to @ref clingo_propagate_init_add_watch() this just removes the watch in the current solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to remove"]
    pub fn clingo_propagate_control_remove_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    );
}
extern "C" {
    #[doc = "! Add the given clause to the solver."]
    #[doc = "!"]
    #[doc = "! This method sets its result to false if the current propagation must be stopped for the solver to backtrack."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] clause the clause to add"]
    #[doc = "! @param[in] size the size of the clause"]
    #[doc = "! @param[in] type the clause type determining its lifetime"]
    #[doc = "! @param[out] result result indicating whether propagation has to be stopped"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_add_clause(
        control: *mut clingo_propagate_control_t,
        clause: *const clingo_literal_t,
        size: usize,
        type_: clingo_clause_type_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagate implied literals (resulting from added clauses)."]
    #[doc = "!"]
    #[doc = "! This method sets its result to false if the current propagation must be stopped for the solver to backtrack."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] result result indicating whether propagation has to be stopped"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_propagate(
        control: *mut clingo_propagate_control_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "! Typedef for @ref ::clingo_propagator::init()."]
pub type clingo_propagator_init_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_init_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::propagate()."]
pub type clingo_propagator_propagate_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::undo()."]
pub type clingo_propagator_undo_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "! Typedef for @ref ::clingo_propagator::check()."]
pub type clingo_propagator_check_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! @see Propagator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagator {
    #[doc = "! This function is called once before each solving step."]
    #[doc = "! It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize the data structures used during propagation."]
    #[doc = "!"]
    #[doc = "! @note This is the last point to access symbolic and theory atoms."]
    #[doc = "! Once the search has started, they are no longer accessible."]
    #[doc = "!"]
    #[doc = "! @param[in] init initizialization object"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_init_callback_t"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            init: *mut clingo_propagate_init_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Can be used to propagate solver literals given a @link clingo_assignment_t partial assignment@endlink."]
    #[doc = "!"]
    #[doc = "! Called during propagation with a non-empty array of @link clingo_propagate_init_add_watch() watched solver literals@endlink"]
    #[doc = "! that have been assigned to true since the last call to either propagate, undo, (or the start of the search) - the change set."]
    #[doc = "! Only watched solver literals are contained in the change set."]
    #[doc = "! Each literal in the change set is true w.r.t. the current @link clingo_assignment_t assignment@endlink."]
    #[doc = "! @ref clingo_propagate_control_add_clause() can be used to add clauses."]
    #[doc = "! If a clause is unit resulting, it can be propagated using @ref clingo_propagate_control_propagate()."]
    #[doc = "! If the result of either of the two methods is false, the propagate function must return immediately."]
    #[doc = "!"]
    #[doc = "! The following snippet shows how to use the methods to add clauses and propagate consequences within the callback."]
    #[doc = "! The important point is to return true (true to indicate there was no error) if the result of either of the methods is false."]
    #[doc = "! ~~~~~~~~~~~~~~~{.c}"]
    #[doc = "! bool result;"]
    #[doc = "! clingo_literal_t clause[] = { ... };"]
    #[doc = "!"]
    #[doc = "! // add a clause"]
    #[doc = "! if (!clingo_propagate_control_add_clause(control, clause, clingo_clause_type_learnt, &result) { return false; }"]
    #[doc = "! if (!result) { return true; }"]
    #[doc = "! // propagate its consequences"]
    #[doc = "! if (!clingo_propagate_control_propagate(control, &result) { return false; }"]
    #[doc = "! if (!result) { return true; }"]
    #[doc = "!"]
    #[doc = "! // add further clauses and propagate them"]
    #[doc = "! ..."]
    #[doc = "!"]
    #[doc = "! return true;"]
    #[doc = "! ~~~~~~~~~~~~~~~"]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! This function can be called from different solving threads."]
    #[doc = "! Each thread has its own assignment and id, which can be obtained using @ref clingo_propagate_control_thread_id()."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] changes the change set"]
    #[doc = "! @param[in] size the size of the change set"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_propagate_callback_t"]
    pub propagate: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Called whenever a solver undoes assignments to watched solver literals."]
    #[doc = "!"]
    #[doc = "! This callback is meant to update assignment dependent state in the propagator."]
    #[doc = "!"]
    #[doc = "! @note No clauses must be propagated in this callback and no errors should be set."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] changes the change set"]
    #[doc = "! @param[in] size the size of the change set"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_undo_callback_t"]
    pub undo: ::std::option::Option<
        unsafe extern "C" fn(
            control: *const clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = "! This function is similar to @ref clingo_propagate_control_propagate() but is called without a change set on propagation fixpoints."]
    #[doc = "!"]
    #[doc = "! When exactly this function is called, can be configured using the @ref clingo_propagate_init_set_check_mode() function."]
    #[doc = "!"]
    #[doc = "! @note This function is called even if no watches have been added."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_check_callback_t"]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function allows a propagator to implement domain-specific heuristics."]
    #[doc = "!"]
    #[doc = "! It is called whenever propagation reaches a fixed point and"]
    #[doc = "! should return a free solver literal that is to be assigned true."]
    #[doc = "! In case multiple propagators are registered,"]
    #[doc = "! this function can return 0 to let a propagator registered later make a decision."]
    #[doc = "! If all propagators return 0, then the fallback literal is"]
    #[doc = "!"]
    #[doc = "! @param[in] thread_id the solver's thread id"]
    #[doc = "! @param[in] assignment the assignment of the solver"]
    #[doc = "! @param[in] fallback the literal choosen by the solver's heuristic"]
    #[doc = "! @param[out] decision the literal to make true"]
    #[doc = "! @return whether the call was successful"]
    pub decide: ::std::option::Option<
        unsafe extern "C" fn(
            thread_id: clingo_id_t,
            assignment: *const clingo_assignment_t,
            fallback: clingo_literal_t,
            data: *mut ::std::os::raw::c_void,
            decision: *mut clingo_literal_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_propagator() {
    assert_eq!(
        ::std::mem::size_of::<clingo_propagator>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_propagator))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_propagator>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_propagator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).propagate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).undo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).check as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).decide as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(decide)
        )
    );
}
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! @see Propagator"]
pub type clingo_propagator_t = clingo_propagator;
#[doc = "!< set the level of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_level: clingo_heuristic_type_e = 0;
#[doc = "!< configure which sign to chose for an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_sign: clingo_heuristic_type_e = 1;
#[doc = "!< modify VSIDS factor of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_factor: clingo_heuristic_type_e = 2;
#[doc = "!< modify the initial VSIDS score of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_init: clingo_heuristic_type_e = 3;
#[doc = "!< set the level of an atom and choose a positive sign"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_true: clingo_heuristic_type_e = 4;
#[doc = "!< set the level of an atom and choose a negative sign"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_false: clingo_heuristic_type_e = 5;
#[doc = "! Enumeration of different heuristic modifiers."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_heuristic_type_e."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_t = ::std::os::raw::c_int;
#[doc = "!< allow an external to be assigned freely"]
pub const clingo_external_type_e_clingo_external_type_free: clingo_external_type_e = 0;
#[doc = "!< assign an external to true"]
pub const clingo_external_type_e_clingo_external_type_true: clingo_external_type_e = 1;
#[doc = "!< assign an external to false"]
pub const clingo_external_type_e_clingo_external_type_false: clingo_external_type_e = 2;
#[doc = "!< no longer treat an atom as external"]
pub const clingo_external_type_e_clingo_external_type_release: clingo_external_type_e = 3;
#[doc = "! Enumeration of different external statements."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_external_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_external_type_e."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_external_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_backend {
    _unused: [u8; 0],
}
#[doc = "! Handle to the backend to add directives in aspif format."]
pub type clingo_backend_t = clingo_backend;
extern "C" {
    #[doc = "! Prepare the backend for usage."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_backend_begin(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Finalize the backend after using it."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_backend_end(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Add a rule to the program."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] body the body literals"]
    #[doc = "! @param[in] body_size the number of literals in the body"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        body: *const clingo_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a weight rule to the program."]
    #[doc = "!"]
    #[doc = "! @attention All weights and the lower bound must be positive."]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] lower_bound the lower bound of the weight rule"]
    #[doc = "! @param[in] body the weighted body literals"]
    #[doc = "! @param[in] body_size the number of weighted literals in the body"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_weight_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        lower_bound: clingo_weight_t,
        body: *const clingo_weighted_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a minimize constraint (or weak constraint) to the program."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] priority the priority of the constraint"]
    #[doc = "! @param[in] literals the weighted literals whose sum to minimize"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_minimize(
        backend: *mut clingo_backend_t,
        priority: clingo_weight_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a projection directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atoms the atoms to project on"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_project(
        backend: *mut clingo_backend_t,
        atoms: *const clingo_atom_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an external statement."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atom the external atom"]
    #[doc = "! @param[in] type the type of the external statement"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_external(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_external_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an assumption directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_assume(
        backend: *mut clingo_backend_t,
        literals: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an heuristic directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atom the target atom"]
    #[doc = "! @param[in] type the type of the heuristic modification"]
    #[doc = "! @param[in] bias the heuristic bias"]
    #[doc = "! @param[in] priority the heuristic priority"]
    #[doc = "! @param[in] condition the condition under which to apply the heuristic modification"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_heuristic(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_heuristic_type_t,
        bias: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_uint,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an edge directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] node_u the start vertex of the edge"]
    #[doc = "! @param[in] node_v the end vertex of the edge"]
    #[doc = "! @param[in] condition the condition under which the edge is part of the graph"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_acyc_edge(
        backend: *mut clingo_backend_t,
        node_u: ::std::os::raw::c_int,
        node_v: ::std::os::raw::c_int,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a fresh atom to be used in aspif directives."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] symbol optional symbol to associate the atom with"]
    #[doc = "! @param[out] atom the resulting atom"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_backend_add_atom(
        backend: *mut clingo_backend_t,
        symbol: *mut clingo_symbol_t,
        atom: *mut clingo_atom_t,
    ) -> bool;
}
#[doc = "!< the entry is a (string) value"]
pub const clingo_configuration_type_e_clingo_configuration_type_value: clingo_configuration_type_e =
    1;
#[doc = "!< the entry is an array"]
pub const clingo_configuration_type_e_clingo_configuration_type_array: clingo_configuration_type_e =
    2;
#[doc = "!< the entry is a map"]
pub const clingo_configuration_type_e_clingo_configuration_type_map: clingo_configuration_type_e =
    4;
#[doc = "! Enumeration for entries of the configuration."]
pub type clingo_configuration_type_e = ::std::os::raw::c_uint;
#[doc = "! Bitset for values of type ::clingo_configuration_type_e."]
pub type clingo_configuration_type_bitset_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_configuration {
    _unused: [u8; 0],
}
#[doc = "! Handle for to the solver configuration."]
pub type clingo_configuration_t = clingo_configuration;
extern "C" {
    #[doc = "! Get the root key of the configuration."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[out] key the root key"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_root(
        configuration: *const clingo_configuration_t,
        key: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key."]
    #[doc = "!"]
    #[doc = "! @note The type is bitset, an entry can have multiple (but at least one) type."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_type(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        type_: *mut clingo_configuration_type_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the description of an entry."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] description the description"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_description(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        description: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_array_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry."]
    #[doc = "!"]
    #[doc = "! @note Some array entries, like fore example the solver configuration, can be accessed past there actual size to add subentries."]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset in the array"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_array_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Query whether the map has a key."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] result whether the key is in the map"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_has_subkey(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset of the name"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_subkey_name(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a entry has a value."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] assigned whether the entry has a value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_is_assigned(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        assigned: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_get_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @pre The given size must be larger or equal to size of the value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the resulting string value"]
    #[doc = "! @param[in] size the size of the given char array"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_get(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        value: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] value the value to set"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_set(
        configuration: *mut clingo_configuration_t,
        key: clingo_id_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = "!< the entry is invalid (has neither of the types below)"]
pub const clingo_statistics_type_e_clingo_statistics_type_empty: clingo_statistics_type_e = 0;
#[doc = "!< the entry is a (double) value"]
pub const clingo_statistics_type_e_clingo_statistics_type_value: clingo_statistics_type_e = 1;
#[doc = "!< the entry is an array"]
pub const clingo_statistics_type_e_clingo_statistics_type_array: clingo_statistics_type_e = 2;
#[doc = "!< the entry is a map"]
pub const clingo_statistics_type_e_clingo_statistics_type_map: clingo_statistics_type_e = 3;
#[doc = "! Enumeration for entries of the statistics."]
pub type clingo_statistics_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_statistics_type."]
pub type clingo_statistics_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_statistic {
    _unused: [u8; 0],
}
#[doc = "! Handle for the solver statistics."]
pub type clingo_statistics_t = clingo_statistic;
extern "C" {
    #[doc = "! Get the root key of the statistics."]
    #[doc = "!"]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[out] key the root key"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_root(statistics: *const clingo_statistics_t, key: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key."]
    #[doc = "!"]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_type(
        statistics: *const clingo_statistics_t,
        key: u64,
        type_: *mut clingo_statistics_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset in the array"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Create the subkey at the end of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] type the type of the new subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_push(
        statistics: *mut clingo_statistics_t,
        key: u64,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Test if the given map contains a specific subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name name of the subkey"]
    #[doc = "! @param[out] result true if the map has a subkey with the given name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_has_subkey(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset of the name"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_subkey_name(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a subkey with the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name of the new subkey"]
    #[doc = "! @param[in] type the type of the new subkey"]
    #[doc = "! @param[out] subkey the index of the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_add_subkey(
        statistics: *mut clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_value_get(
        statistics: *const clingo_statistics_t,
        key: u64,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the new value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_value_set(
        statistics: *mut clingo_statistics_t,
        key: u64,
        value: f64,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_control {
    _unused: [u8; 0],
}
#[doc = "! Object to add clauses during search."]
pub type clingo_solve_control_t = clingo_solve_control;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_model {
    _unused: [u8; 0],
}
#[doc = "! Object representing a model."]
pub type clingo_model_t = clingo_model;
#[doc = "!< The model represents a stable model."]
pub const clingo_model_type_e_clingo_model_type_stable_model: clingo_model_type_e = 0;
#[doc = "!< The model represents a set of brave consequences."]
pub const clingo_model_type_e_clingo_model_type_brave_consequences: clingo_model_type_e = 1;
#[doc = "!< The model represents a set of cautious consequences."]
pub const clingo_model_type_e_clingo_model_type_cautious_consequences: clingo_model_type_e = 2;
#[doc = "! Enumeration for the different model types."]
pub type clingo_model_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_model_type_e."]
pub type clingo_model_type_t = ::std::os::raw::c_int;
#[doc = "!< Select CSP assignments."]
pub const clingo_show_type_e_clingo_show_type_csp: clingo_show_type_e = 1;
#[doc = "!< Select shown atoms and terms."]
pub const clingo_show_type_e_clingo_show_type_shown: clingo_show_type_e = 2;
#[doc = "!< Select all atoms."]
pub const clingo_show_type_e_clingo_show_type_atoms: clingo_show_type_e = 4;
#[doc = "!< Select all terms."]
pub const clingo_show_type_e_clingo_show_type_terms: clingo_show_type_e = 8;
#[doc = "!< Select symbols added by theory."]
pub const clingo_show_type_e_clingo_show_type_theory: clingo_show_type_e = 16;
#[doc = "!< Select everything."]
pub const clingo_show_type_e_clingo_show_type_all: clingo_show_type_e = 31;
#[doc = "!< Select false instead of true atoms (::clingo_show_type_atoms) or terms (::clingo_show_type_terms)."]
pub const clingo_show_type_e_clingo_show_type_complement: clingo_show_type_e = 32;
#[doc = "! Enumeration of bit flags to select symbols in models."]
pub type clingo_show_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_show_type_e."]
pub type clingo_show_type_bitset_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! Get the type of the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] type the type of the model"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_type(model: *const clingo_model_t, type_: *mut clingo_model_type_t)
        -> bool;
}
extern "C" {
    #[doc = "! Get the running number of the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] number the number of the model"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_number(model: *const clingo_model_t, number: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the number of symbols of the selected types in the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] show which symbols to select"]
    #[doc = "! @param[out] size the number symbols"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_model_symbols_size(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbols of the selected types in the model."]
    #[doc = "!"]
    #[doc = "! @note CSP assignments are represented using functions with name \"$\""]
    #[doc = "! where the first argument is the name of the CSP variable and the second one its"]
    #[doc = "! value."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] show which symbols to select"]
    #[doc = "! @param[out] symbols the resulting symbols"]
    #[doc = "! @param[in] size the number of selected symbols"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_symbols_size()"]
    pub fn clingo_model_symbols(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        symbols: *mut clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Constant time lookup to test whether an atom is in a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] atom the atom to lookup"]
    #[doc = "! @param[out] contained whether the atom is contained"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_contains(
        model: *const clingo_model_t,
        atom: clingo_symbol_t,
        contained: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a program literal is true in a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] literal the literal to lookup"]
    #[doc = "! @param[out] result whether the literal is true"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_is_true(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of cost values of a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] size the number of costs"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_cost_size(model: *const clingo_model_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the cost vector of a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] costs the resulting costs"]
    #[doc = "! @param[in] size the number of costs"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_cost_size()"]
    #[doc = "! @see clingo_model_optimality_proven()"]
    pub fn clingo_model_cost(model: *const clingo_model_t, costs: *mut i64, size: usize) -> bool;
}
extern "C" {
    #[doc = "! Whether the optimality of a model has been proven."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] proven whether the optimality has been proven"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_cost()"]
    pub fn clingo_model_optimality_proven(model: *const clingo_model_t, proven: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the solver thread that found the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] id the resulting thread id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_thread_id(model: *const clingo_model_t, id: *mut clingo_id_t) -> bool;
}
extern "C" {
    #[doc = "! Add symbols to the model."]
    #[doc = "!"]
    #[doc = "! These symbols will appear in clingo's output, which means that this"]
    #[doc = "! function is only meaningful if there is an underlying clingo application."]
    #[doc = "! Only models passed to the ::clingo_solve_event_callback_t are extendable."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] symbols the symbols to add"]
    #[doc = "! @param[in] size the number of symbols to add"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_extend(
        model: *mut clingo_model_t,
        symbols: *const clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the associated solve control object of a model."]
    #[doc = "!"]
    #[doc = "! This object allows for adding clauses during model enumeration."]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] control the resulting solve control object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_context(
        model: *const clingo_model_t,
        control: *mut *mut clingo_solve_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_solve_control_symbolic_atoms(
        control: *const clingo_solve_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a clause that applies to the current solving step during model"]
    #[doc = "! enumeration."]
    #[doc = "!"]
    #[doc = "! @note The @ref Propagator module provides a more sophisticated"]
    #[doc = "! interface to add clauses - even on partial assignments."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] clause array of literals representing the clause"]
    #[doc = "! @param[in] size the size of the literal array"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if adding the clause fails"]
    pub fn clingo_solve_control_add_clause(
        control: *mut clingo_solve_control_t,
        clause: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
pub const clingo_solve_result_e_clingo_solve_result_satisfiable: clingo_solve_result_e = 1;
pub const clingo_solve_result_e_clingo_solve_result_unsatisfiable: clingo_solve_result_e = 2;
pub const clingo_solve_result_e_clingo_solve_result_exhausted: clingo_solve_result_e = 4;
pub const clingo_solve_result_e_clingo_solve_result_interrupted: clingo_solve_result_e = 8;
pub type clingo_solve_result_e = ::std::os::raw::c_uint;
pub type clingo_solve_result_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Enable non-blocking search."]
pub const clingo_solve_mode_e_clingo_solve_mode_async: clingo_solve_mode_e = 1;
#[doc = "!< Yield models in calls to clingo_solve_handle_model."]
pub const clingo_solve_mode_e_clingo_solve_mode_yield: clingo_solve_mode_e = 2;
#[doc = "! Enumeration of solve modes."]
pub type clingo_solve_mode_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_mode_e."]
pub type clingo_solve_mode_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Issued if a model is found."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_model: clingo_solve_event_type_e = 0;
#[doc = "!< Issued if an optimization problem is found unsatisfiable."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_unsat: clingo_solve_event_type_e = 1;
#[doc = "!< Issued when the statistics can be updated."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_statistics: clingo_solve_event_type_e =
    2;
#[doc = "!< Issued if the search has completed."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_finish: clingo_solve_event_type_e = 3;
#[doc = "! Enumeration of solve events."]
pub type clingo_solve_event_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_event_type_e."]
pub type clingo_solve_event_type_t = ::std::os::raw::c_uint;
#[doc = "! Callback function called during search to notify when the search is finished or a model is ready."]
#[doc = "!"]
#[doc = "! If a (non-recoverable) clingo API function fails in this callback, it must return false."]
#[doc = "! In case of errors not related to clingo, set error code ::clingo_error_unknown and return false to stop solving with an error."]
#[doc = "!"]
#[doc = "! The event is either a pointer to a model, a pointer to an int64_t* and a size_t, a pointer to two statistics objects (per step and accumulated statistics), or a solve result."]
#[doc = "! @attention If the search is finished, the model is NULL."]
#[doc = "!"]
#[doc = "! @param[in] event the current event."]
#[doc = "! @param[in] data user data of the callback"]
#[doc = "! @param[out] goon can be set to false to stop solving"]
#[doc = "! @return whether the call was successful"]
#[doc = "!"]
#[doc = "! @see clingo_control_solve()"]
pub type clingo_solve_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: clingo_solve_event_type_t,
        event: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        goon: *mut bool,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_handle {
    _unused: [u8; 0],
}
#[doc = "! Search handle to a solve call."]
#[doc = "!"]
#[doc = "! @see clingo_control_solve()"]
pub type clingo_solve_handle_t = clingo_solve_handle;
extern "C" {
    #[doc = "! Get the next solve result."]
    #[doc = "!"]
    #[doc = "! Blocks until the result is ready."]
    #[doc = "! When yielding partial solve results can be obtained, i.e.,"]
    #[doc = "! when a model is ready, the result will be satisfiable but neither the search exhausted nor the optimality proven."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[out] result the solve result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_get(
        handle: *mut clingo_solve_handle_t,
        result: *mut clingo_solve_result_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Wait for the specified amount of time to check if the next result is ready."]
    #[doc = "!"]
    #[doc = "! If the time is set to zero, this function can be used to poll if the search is still active."]
    #[doc = "! If the time is negative, the function blocks until the search is finished."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[in] timeout the maximum time to wait"]
    #[doc = "! @param[out] result whether the search has finished"]
    pub fn clingo_solve_handle_wait(
        handle: *mut clingo_solve_handle_t,
        timeout: f64,
        result: *mut bool,
    );
}
extern "C" {
    #[doc = "! Get the next model (or zero if there are no more models)."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[out] model the model (it is NULL if there are no more models)"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_model(
        handle: *mut clingo_solve_handle_t,
        model: *mut *const clingo_model_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! When a problem is unsatisfiable, get a subset of the assumptions that made the problem unsatisfiable."]
    #[doc = "!"]
    #[doc = "! If the program is not unsatisfiable, core is set to NULL and size to zero."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[out] core pointer where to store the core"]
    #[doc = "! @param[out] size size of the given array"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_solve_handle_core(
        handle: *mut clingo_solve_handle_t,
        core: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Discards the last model and starts the search for the next one."]
    #[doc = "!"]
    #[doc = "! If the search has been started asynchronously, this function continues the search in the background."]
    #[doc = "!"]
    #[doc = "! @note This function does not block."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_resume(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stop the running search and block until done."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_cancel(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stops the running search and releases the handle."]
    #[doc = "!"]
    #[doc = "! Blocks until the search is stopped (as if an implicit cancel was called before the handle is released)."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_close(handle: *mut clingo_solve_handle_t) -> bool;
}
#[doc = "!< Theory tuples \"(t1,...,tn)\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_tuple:
    clingo_ast_theory_sequence_type_e = 0;
#[doc = "!< Theory lists \"[t1,...,tn]\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_list:
    clingo_ast_theory_sequence_type_e = 1;
#[doc = "!< Theory sets \"{t1,...,tn}\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_set:
    clingo_ast_theory_sequence_type_e = 2;
#[doc = "! Enumeration of theory sequence types."]
pub type clingo_ast_theory_sequence_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_sequence_type_e."]
pub type clingo_ast_theory_sequence_type_t = ::std::os::raw::c_int;
#[doc = "!< Operator \">\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_greater_than:
    clingo_ast_comparison_operator_e = 0;
#[doc = "!< Operator \"<\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_less_than:
    clingo_ast_comparison_operator_e = 1;
#[doc = "!< Operator \"<=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_less_equal:
    clingo_ast_comparison_operator_e = 2;
#[doc = "!< Operator \">=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_greater_equal:
    clingo_ast_comparison_operator_e = 3;
#[doc = "!< Operator \"!=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_not_equal:
    clingo_ast_comparison_operator_e = 4;
#[doc = "!< Operator \"==\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_equal:
    clingo_ast_comparison_operator_e = 5;
#[doc = "! Enumeration of comparison relations."]
pub type clingo_ast_comparison_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_comparison_operator_e."]
pub type clingo_ast_comparison_operator_t = ::std::os::raw::c_int;
#[doc = "!< For positive literals."]
pub const clingo_ast_sign_e_clingo_ast_sign_no_sign: clingo_ast_sign_e = 0;
#[doc = "!< For negative literals (prefix \"not\")."]
pub const clingo_ast_sign_e_clingo_ast_sign_negation: clingo_ast_sign_e = 1;
#[doc = "!< For double negated literals (prefix \"not not\")."]
pub const clingo_ast_sign_e_clingo_ast_sign_double_negation: clingo_ast_sign_e = 2;
#[doc = "! Enumeration of signs."]
pub type clingo_ast_sign_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_sign_t."]
pub type clingo_ast_sign_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_minus: clingo_ast_unary_operator_e =
    0;
#[doc = "!< Operator \"~\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_negation:
    clingo_ast_unary_operator_e = 1;
#[doc = "!< Operator \"|.|\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_absolute:
    clingo_ast_unary_operator_e = 2;
#[doc = "! Enumeration of unary operators."]
pub type clingo_ast_unary_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_unary_operator_e."]
pub type clingo_ast_unary_operator_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"^\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_xor:
    clingo_ast_binary_operator_e = 0;
#[doc = "!< Operator \"?\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_or: clingo_ast_binary_operator_e =
    1;
#[doc = "!< Operator \"&\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_and:
    clingo_ast_binary_operator_e = 2;
#[doc = "!< Operator \"+\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_plus:
    clingo_ast_binary_operator_e = 3;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_minus:
    clingo_ast_binary_operator_e = 4;
#[doc = "!< Operator \"*\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_multiplication:
    clingo_ast_binary_operator_e = 5;
#[doc = "!< Operator \"/\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_division:
    clingo_ast_binary_operator_e = 6;
#[doc = "!< Operator \"\\\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_modulo:
    clingo_ast_binary_operator_e = 7;
#[doc = "!< Operator \"**\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_power:
    clingo_ast_binary_operator_e = 8;
#[doc = "! Enumeration of binary operators."]
pub type clingo_ast_binary_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_binary_operator_e."]
pub type clingo_ast_binary_operator_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"^\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_count:
    clingo_ast_aggregate_function_e = 0;
#[doc = "!< Operator \"?\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_sum:
    clingo_ast_aggregate_function_e = 1;
#[doc = "!< Operator \"&\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_sump:
    clingo_ast_aggregate_function_e = 2;
#[doc = "!< Operator \"+\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_min:
    clingo_ast_aggregate_function_e = 3;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_max:
    clingo_ast_aggregate_function_e = 4;
#[doc = "! Enumeration of aggregate functions."]
pub type clingo_ast_aggregate_function_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_aggregate_function_e."]
pub type clingo_ast_aggregate_function_t = ::std::os::raw::c_int;
#[doc = "!< An unary theory operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_unary:
    clingo_ast_theory_operator_type_e = 0;
#[doc = "!< A left associative binary operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_binary_left:
    clingo_ast_theory_operator_type_e = 1;
#[doc = "!< A right associative binary operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_binary_right:
    clingo_ast_theory_operator_type_e = 2;
#[doc = "! Enumeration of theory operators."]
pub type clingo_ast_theory_operator_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_operator_type_e."]
pub type clingo_ast_theory_operator_type_t = ::std::os::raw::c_int;
#[doc = "!< For theory atoms that can appear in the head."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_head:
    clingo_ast_theory_atom_definition_type_e = 0;
#[doc = "!< For theory atoms that can appear in the body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_body:
    clingo_ast_theory_atom_definition_type_e = 1;
#[doc = "!< For theory atoms that can appear in both head and body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_any:
    clingo_ast_theory_atom_definition_type_e = 2;
#[doc = "!< For theory atoms that must not have a body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_directive : clingo_ast_theory_atom_definition_type_e = 3 ;
#[doc = "! Enumeration of the theory atom types."]
pub type clingo_ast_theory_atom_definition_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_atom_definition_type_e."]
pub type clingo_ast_theory_atom_definition_type_t = ::std::os::raw::c_int;
pub const clingo_ast_type_e_clingo_ast_type_id: clingo_ast_type_e = 0;
pub const clingo_ast_type_e_clingo_ast_type_variable: clingo_ast_type_e = 1;
pub const clingo_ast_type_e_clingo_ast_type_symbolic_term: clingo_ast_type_e = 2;
pub const clingo_ast_type_e_clingo_ast_type_unary_operation: clingo_ast_type_e = 3;
pub const clingo_ast_type_e_clingo_ast_type_binary_operation: clingo_ast_type_e = 4;
pub const clingo_ast_type_e_clingo_ast_type_interval: clingo_ast_type_e = 5;
pub const clingo_ast_type_e_clingo_ast_type_function: clingo_ast_type_e = 6;
pub const clingo_ast_type_e_clingo_ast_type_pool: clingo_ast_type_e = 7;
pub const clingo_ast_type_e_clingo_ast_type_csp_product: clingo_ast_type_e = 8;
pub const clingo_ast_type_e_clingo_ast_type_csp_sum: clingo_ast_type_e = 9;
pub const clingo_ast_type_e_clingo_ast_type_csp_guard: clingo_ast_type_e = 10;
pub const clingo_ast_type_e_clingo_ast_type_boolean_constant: clingo_ast_type_e = 11;
pub const clingo_ast_type_e_clingo_ast_type_symbolic_atom: clingo_ast_type_e = 12;
pub const clingo_ast_type_e_clingo_ast_type_comparison: clingo_ast_type_e = 13;
pub const clingo_ast_type_e_clingo_ast_type_csp_literal: clingo_ast_type_e = 14;
pub const clingo_ast_type_e_clingo_ast_type_aggregate_guard: clingo_ast_type_e = 15;
pub const clingo_ast_type_e_clingo_ast_type_conditional_literal: clingo_ast_type_e = 16;
pub const clingo_ast_type_e_clingo_ast_type_aggregate: clingo_ast_type_e = 17;
pub const clingo_ast_type_e_clingo_ast_type_body_aggregate_element: clingo_ast_type_e = 18;
pub const clingo_ast_type_e_clingo_ast_type_body_aggregate: clingo_ast_type_e = 19;
pub const clingo_ast_type_e_clingo_ast_type_head_aggregate_element: clingo_ast_type_e = 20;
pub const clingo_ast_type_e_clingo_ast_type_head_aggregate: clingo_ast_type_e = 21;
pub const clingo_ast_type_e_clingo_ast_type_disjunction: clingo_ast_type_e = 22;
pub const clingo_ast_type_e_clingo_ast_type_disjoint_element: clingo_ast_type_e = 23;
pub const clingo_ast_type_e_clingo_ast_type_disjoint: clingo_ast_type_e = 24;
pub const clingo_ast_type_e_clingo_ast_type_theory_sequence: clingo_ast_type_e = 25;
pub const clingo_ast_type_e_clingo_ast_type_theory_function: clingo_ast_type_e = 26;
pub const clingo_ast_type_e_clingo_ast_type_theory_unparsed_term_element: clingo_ast_type_e = 27;
pub const clingo_ast_type_e_clingo_ast_type_theory_unparsed_term: clingo_ast_type_e = 28;
pub const clingo_ast_type_e_clingo_ast_type_theory_guard: clingo_ast_type_e = 29;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom_element: clingo_ast_type_e = 30;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom: clingo_ast_type_e = 31;
pub const clingo_ast_type_e_clingo_ast_type_literal: clingo_ast_type_e = 32;
pub const clingo_ast_type_e_clingo_ast_type_theory_operator_definition: clingo_ast_type_e = 33;
pub const clingo_ast_type_e_clingo_ast_type_theory_term_definition: clingo_ast_type_e = 34;
pub const clingo_ast_type_e_clingo_ast_type_theory_guard_definition: clingo_ast_type_e = 35;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom_definition: clingo_ast_type_e = 36;
pub const clingo_ast_type_e_clingo_ast_type_rule: clingo_ast_type_e = 37;
pub const clingo_ast_type_e_clingo_ast_type_definition: clingo_ast_type_e = 38;
pub const clingo_ast_type_e_clingo_ast_type_show_signature: clingo_ast_type_e = 39;
pub const clingo_ast_type_e_clingo_ast_type_show_term: clingo_ast_type_e = 40;
pub const clingo_ast_type_e_clingo_ast_type_minimize: clingo_ast_type_e = 41;
pub const clingo_ast_type_e_clingo_ast_type_script: clingo_ast_type_e = 42;
pub const clingo_ast_type_e_clingo_ast_type_program: clingo_ast_type_e = 43;
pub const clingo_ast_type_e_clingo_ast_type_external: clingo_ast_type_e = 44;
pub const clingo_ast_type_e_clingo_ast_type_edge: clingo_ast_type_e = 45;
pub const clingo_ast_type_e_clingo_ast_type_heuristic: clingo_ast_type_e = 46;
pub const clingo_ast_type_e_clingo_ast_type_project_atom: clingo_ast_type_e = 47;
pub const clingo_ast_type_e_clingo_ast_type_project_signature: clingo_ast_type_e = 48;
pub const clingo_ast_type_e_clingo_ast_type_defined: clingo_ast_type_e = 49;
pub const clingo_ast_type_e_clingo_ast_type_theory_definition: clingo_ast_type_e = 50;
#[doc = "! Enumeration of AST types."]
pub type clingo_ast_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_type_e."]
pub type clingo_ast_type_t = ::std::os::raw::c_int;
#[doc = "!< For an attribute of type \"int\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_number:
    clingo_ast_attribute_type_e = 0;
#[doc = "!< For an attribute of type \"clingo_ast_symbol_t\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_symbol:
    clingo_ast_attribute_type_e = 1;
#[doc = "!< For an attribute of type \"clingo_location_t\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_location:
    clingo_ast_attribute_type_e = 2;
#[doc = "!< For an attribute of type \"char const *\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_string:
    clingo_ast_attribute_type_e = 3;
#[doc = "!< For an attribute of type \"clingo_ast_t *\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_ast: clingo_ast_attribute_type_e =
    4;
#[doc = "!< For an attribute of type \"clingo_ast_t *\" that can be NULL."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_optional_ast:
    clingo_ast_attribute_type_e = 5;
#[doc = "!< For an attribute of type \"char const **\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_string_array:
    clingo_ast_attribute_type_e = 6;
#[doc = "!< For an attribute of type \"clingo_ast_t **\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_ast_array:
    clingo_ast_attribute_type_e = 7;
#[doc = "! Enumeration of attributes types used by the AST."]
pub type clingo_ast_attribute_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_attribute_type."]
pub type clingo_ast_attribute_type_t = ::std::os::raw::c_int;
pub const clingo_ast_attribute_e_clingo_ast_attribute_argument: clingo_ast_attribute_e = 0;
pub const clingo_ast_attribute_e_clingo_ast_attribute_arguments: clingo_ast_attribute_e = 1;
pub const clingo_ast_attribute_e_clingo_ast_attribute_arity: clingo_ast_attribute_e = 2;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atom: clingo_ast_attribute_e = 3;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atoms: clingo_ast_attribute_e = 4;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atom_type: clingo_ast_attribute_e = 5;
pub const clingo_ast_attribute_e_clingo_ast_attribute_bias: clingo_ast_attribute_e = 6;
pub const clingo_ast_attribute_e_clingo_ast_attribute_body: clingo_ast_attribute_e = 7;
pub const clingo_ast_attribute_e_clingo_ast_attribute_code: clingo_ast_attribute_e = 8;
pub const clingo_ast_attribute_e_clingo_ast_attribute_coefficient: clingo_ast_attribute_e = 9;
pub const clingo_ast_attribute_e_clingo_ast_attribute_comparison: clingo_ast_attribute_e = 10;
pub const clingo_ast_attribute_e_clingo_ast_attribute_condition: clingo_ast_attribute_e = 11;
pub const clingo_ast_attribute_e_clingo_ast_attribute_csp: clingo_ast_attribute_e = 12;
pub const clingo_ast_attribute_e_clingo_ast_attribute_elements: clingo_ast_attribute_e = 13;
pub const clingo_ast_attribute_e_clingo_ast_attribute_external: clingo_ast_attribute_e = 14;
pub const clingo_ast_attribute_e_clingo_ast_attribute_external_type: clingo_ast_attribute_e = 15;
pub const clingo_ast_attribute_e_clingo_ast_attribute_function: clingo_ast_attribute_e = 16;
pub const clingo_ast_attribute_e_clingo_ast_attribute_guard: clingo_ast_attribute_e = 17;
pub const clingo_ast_attribute_e_clingo_ast_attribute_guards: clingo_ast_attribute_e = 18;
pub const clingo_ast_attribute_e_clingo_ast_attribute_head: clingo_ast_attribute_e = 19;
pub const clingo_ast_attribute_e_clingo_ast_attribute_is_default: clingo_ast_attribute_e = 20;
pub const clingo_ast_attribute_e_clingo_ast_attribute_left: clingo_ast_attribute_e = 21;
pub const clingo_ast_attribute_e_clingo_ast_attribute_left_guard: clingo_ast_attribute_e = 22;
pub const clingo_ast_attribute_e_clingo_ast_attribute_literal: clingo_ast_attribute_e = 23;
pub const clingo_ast_attribute_e_clingo_ast_attribute_location: clingo_ast_attribute_e = 24;
pub const clingo_ast_attribute_e_clingo_ast_attribute_modifier: clingo_ast_attribute_e = 25;
pub const clingo_ast_attribute_e_clingo_ast_attribute_name: clingo_ast_attribute_e = 26;
pub const clingo_ast_attribute_e_clingo_ast_attribute_node_u: clingo_ast_attribute_e = 27;
pub const clingo_ast_attribute_e_clingo_ast_attribute_node_v: clingo_ast_attribute_e = 28;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operator_name: clingo_ast_attribute_e = 29;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operator_type: clingo_ast_attribute_e = 30;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operators: clingo_ast_attribute_e = 31;
pub const clingo_ast_attribute_e_clingo_ast_attribute_parameters: clingo_ast_attribute_e = 32;
pub const clingo_ast_attribute_e_clingo_ast_attribute_positive: clingo_ast_attribute_e = 33;
pub const clingo_ast_attribute_e_clingo_ast_attribute_priority: clingo_ast_attribute_e = 34;
pub const clingo_ast_attribute_e_clingo_ast_attribute_right: clingo_ast_attribute_e = 35;
pub const clingo_ast_attribute_e_clingo_ast_attribute_right_guard: clingo_ast_attribute_e = 36;
pub const clingo_ast_attribute_e_clingo_ast_attribute_sequence_type: clingo_ast_attribute_e = 37;
pub const clingo_ast_attribute_e_clingo_ast_attribute_sign: clingo_ast_attribute_e = 38;
pub const clingo_ast_attribute_e_clingo_ast_attribute_symbol: clingo_ast_attribute_e = 39;
pub const clingo_ast_attribute_e_clingo_ast_attribute_term: clingo_ast_attribute_e = 40;
pub const clingo_ast_attribute_e_clingo_ast_attribute_terms: clingo_ast_attribute_e = 41;
pub const clingo_ast_attribute_e_clingo_ast_attribute_value: clingo_ast_attribute_e = 42;
pub const clingo_ast_attribute_e_clingo_ast_attribute_variable: clingo_ast_attribute_e = 43;
pub const clingo_ast_attribute_e_clingo_ast_attribute_weight: clingo_ast_attribute_e = 44;
#[doc = "! Enumeration of attributes used by the AST."]
pub type clingo_ast_attribute_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_attribute_e."]
pub type clingo_ast_attribute_t = ::std::os::raw::c_int;
#[doc = "! Struct to map attributes to their string representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_attribute_names {
    pub names: *const *const ::std::os::raw::c_char,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_attribute_names() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_attribute_names>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_attribute_names))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_attribute_names>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_attribute_names))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_attribute_names>())).names as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_attribute_names),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_attribute_names>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_attribute_names),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct to map attributes to their string representation."]
pub type clingo_ast_attribute_names_t = clingo_ast_attribute_names;
extern "C" {
    #[doc = "! A map from attributes to their string representation."]
    pub static mut g_clingo_ast_attribute_names: clingo_ast_attribute_names_t;
}
#[doc = "! Struct to define an argument that consists of a name and a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_argument {
    pub attribute: clingo_ast_attribute_t,
    pub type_: clingo_ast_attribute_type_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_argument() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_argument>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_argument>(),
        4usize,
        concat!("Alignment of ", stringify!(clingo_ast_argument))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_argument>())).attribute as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_argument),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_argument>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_argument),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "! Struct to define an argument that consists of a name and a type."]
pub type clingo_ast_argument_t = clingo_ast_argument;
#[doc = "! A lists of required attributes to construct an AST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_constructor {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *const clingo_ast_argument_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_constructor() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_constructor>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_constructor))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_constructor>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_constructor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_constructor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_constructor>())).arguments as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_constructor>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! A lists of required attributes to construct an AST."]
pub type clingo_ast_constructor_t = clingo_ast_constructor;
#[doc = "! Struct to map AST types to lists of required attributes to construct ASTs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_constructors {
    pub constructors: *const clingo_ast_constructor_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_constructors() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_constructors>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_constructors))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_constructors>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_constructors))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_constructors>())).constructors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructors),
            "::",
            stringify!(constructors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_constructors>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructors),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct to map AST types to lists of required attributes to construct ASTs."]
pub type clingo_ast_constructors_t = clingo_ast_constructors;
extern "C" {
    #[doc = "! A map from AST types to their constructors."]
    #[doc = "!"]
    #[doc = "! @note The idea of this variable is to provide enough information to auto-generate code for language bindings."]
    pub static mut g_clingo_ast_constructors: clingo_ast_constructors_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast {
    _unused: [u8; 0],
}
#[doc = "! This struct provides a view to nodes in the AST."]
pub type clingo_ast_t = clingo_ast;
extern "C" {
    #[doc = "! Construct an AST of the given type."]
    #[doc = "!"]
    #[doc = "! @note The arguments corresponding to the given type can be inspected using \"g_clingo_ast_constructors.constructors[type]\"."]
    #[doc = "!"]
    #[doc = "! @param[in] type the type of AST to construct"]
    #[doc = "! @param[out] ast the resulting AST"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if one of the arguments is incompatible with the type"]
    pub fn clingo_ast_build(type_: clingo_ast_type_t, ast: *mut *mut clingo_ast_t, ...) -> bool;
}
extern "C" {
    #[doc = "! Increment the reference count of an AST node."]
    #[doc = "!"]
    #[doc = "! @note All functions that return AST nodes already increment the reference count."]
    #[doc = "! The reference count of callback arguments is not incremented."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    pub fn clingo_ast_acquire(ast: *mut clingo_ast_t);
}
extern "C" {
    #[doc = "! Decrement the reference count of an AST node."]
    #[doc = "!"]
    #[doc = "! @note The node is deleted if the reference count reaches zero."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    pub fn clingo_ast_release(ast: *mut clingo_ast_t);
}
extern "C" {
    #[doc = "! Create a shallow copy of an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the AST to copy"]
    #[doc = "! @param[out] copy the resulting AST"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_copy(ast: *mut clingo_ast_t, copy: *mut *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Create a deep copy of an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the AST to copy"]
    #[doc = "! @param[out] copy the resulting AST"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_deep_copy(ast: *mut clingo_ast_t, copy: *mut *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Less than compare two AST nodes."]
    #[doc = "!"]
    #[doc = "! @param[in] a the left-hand-side AST"]
    #[doc = "! @param[in] b the right-hand-side AST"]
    #[doc = "! @return the result of the comparison"]
    pub fn clingo_ast_less_than(a: *mut clingo_ast_t, b: *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Equality compare two AST nodes."]
    #[doc = "!"]
    #[doc = "! @param[in] a the left-hand-side AST"]
    #[doc = "! @param[in] b the right-hand-side AST"]
    #[doc = "! @return the result of the comparison"]
    pub fn clingo_ast_equal(a: *mut clingo_ast_t, b: *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Compute a hash for an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @return the resulting hash code"]
    pub fn clingo_ast_hash(ast: *mut clingo_ast_t) -> usize;
}
extern "C" {
    #[doc = "! Get the size of the string representation of an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[out] size the size of the string representation"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_to_string_size(ast: *mut clingo_ast_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[out] string the string representation"]
    #[doc = "! @param[out] size the size of the string representation"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_to_string(
        ast: *mut clingo_ast_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of an AST node."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_get_type(ast: *mut clingo_ast_t, type_: *mut clingo_ast_type_t) -> bool;
}
extern "C" {
    #[doc = "! Check if an AST has the given attribute."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the attribute to check"]
    #[doc = "! @param[out] has_attribute the result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_has_attribute(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        has_attribute: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of the given AST."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_type(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        type_: *mut clingo_ast_attribute_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_number\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_number(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_number\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_number(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_symbol\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_symbol(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_symbol\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_symbol(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_location\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_location(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_location_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_location\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_location(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *const clingo_location_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_string\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_string(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_string\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_string(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_ast\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_ast\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_optional_ast\"."]
    #[doc = "!"]
    #[doc = "! @note The value might be \"NULL\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_optional_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_optional_ast\"."]
    #[doc = "!"]
    #[doc = "! @note The value might be \"NULL\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_optional_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_set_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove an element from an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_delete_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an attribute of type \"clingo_ast_attribute_type_string_array\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_size_string_array(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Insert a value into an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_insert_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_set_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove an element from an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_delete_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an attribute of type \"clingo_ast_attribute_type_ast_array\"."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_size_ast_array(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Insert a value into an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] attribute the target attribute"]
    #[doc = "! @param[in] index the target index"]
    #[doc = "! @param[in] value the value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_insert_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut clingo_ast_t,
    ) -> bool;
}
#[doc = "! Callback function to intercept AST nodes."]
#[doc = "!"]
#[doc = "! @param[in] ast the AST"]
#[doc = "! @param[in] data a user data pointer"]
#[doc = "! @return whether the call was successful"]
pub type clingo_ast_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ast: *mut clingo_ast_t, data: *mut ::std::os::raw::c_void) -> bool,
>;
extern "C" {
    #[doc = "! Parse the given program and return an abstract syntax tree for each statement via a callback."]
    #[doc = "!"]
    #[doc = "! @param[in] program the program in gringo syntax"]
    #[doc = "! @param[in] callback the callback reporting statements"]
    #[doc = "! @param[in] callback_data user data for the callback"]
    #[doc = "! @param[in] logger callback to report messages during parsing"]
    #[doc = "! @param[in] logger_data user data for the logger"]
    #[doc = "! @param[in] message_limit the maximum number of times the logger is called"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_parse_string(
        program: *const ::std::os::raw::c_char,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "! Parse the programs in the given list of files and return an abstract syntax tree for each statement via a callback."]
    #[doc = "!"]
    #[doc = "! The function follows clingo's handling of files on the command line."]
    #[doc = "! Filename \"-\" is treated as \"STDIN\" and if an empty list is given, then the parser will read from \"STDIN\"."]
    #[doc = "!"]
    #[doc = "! @param[in] files the beginning of the file name array"]
    #[doc = "! @param[in] size the number of file names"]
    #[doc = "! @param[in] callback the callback reporting statements"]
    #[doc = "! @param[in] callback_data user data for the callback"]
    #[doc = "! @param[in] logger callback to report messages during parsing"]
    #[doc = "! @param[in] logger_data user data for the logger"]
    #[doc = "! @param[in] message_limit the maximum number of times the logger is called"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_parse_files(
        files: *const *const ::std::os::raw::c_char,
        size: usize,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_program_builder {
    _unused: [u8; 0],
}
#[doc = "! Object to build non-ground programs."]
pub type clingo_program_builder_t = clingo_program_builder;
extern "C" {
    #[doc = "! Begin building a program."]
    #[doc = "!"]
    #[doc = "! @param[in] builder the target program builder"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_program_builder_begin(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    #[doc = "! End building a program."]
    #[doc = "!"]
    #[doc = "! @param[in] builder the target program builder"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_program_builder_end(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    #[doc = "! Adds a statement to the program."]
    #[doc = "!"]
    #[doc = "! @attention @ref clingo_program_builder_begin() must be called before adding statements and @ref clingo_program_builder_end() must be called after all statements have been added."]
    #[doc = "! @param[in] builder the target program builder"]
    #[doc = "! @param[in] ast the AST node to add"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime for statements of invalid form or AST nodes that do not represent statements"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_program_builder_add(
        builder: *mut clingo_program_builder_t,
        ast: *mut clingo_ast_t,
    ) -> bool;
}
#[doc = "!< To only unpool conditions of conditional literals."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_condition: clingo_ast_unpool_type_e = 1;
#[doc = "!< To unpool everything except conditions of conditional literals."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_other: clingo_ast_unpool_type_e = 2;
#[doc = "!< To unpool everything."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_all: clingo_ast_unpool_type_e = 3;
#[doc = "! Enum to configure unpooling."]
pub type clingo_ast_unpool_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_unpool_type_e."]
pub type clingo_ast_unpool_type_bitset_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Unpool the given AST."]
    #[doc = "!"]
    #[doc = "! @param[in] ast the target AST"]
    #[doc = "! @param[in] unpool_type what to unpool"]
    #[doc = "! @param[in] callback the callback to report ASTs"]
    #[doc = "! @param[in] callback_data user data for the callback"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_unpool(
        ast: *mut clingo_ast_t,
        unpool_type: clingo_ast_unpool_type_bitset_t,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver."]
#[doc = "!"]
#[doc = "! @note This interface is closely modeled after the aspif format."]
#[doc = "! For more information please refer to the specification of the aspif format."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! If one of the callbacks in the struct fails, grounding is stopped."]
#[doc = "! If a non-recoverable clingo API call fails, a callback must return false."]
#[doc = "! Otherwise ::clingo_error_unknown should be set and false returned."]
#[doc = "!"]
#[doc = "! @see clingo_control_register_observer()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ground_program_observer {
    #[doc = "! Called once in the beginning."]
    #[doc = "!"]
    #[doc = "! If the incremental flag is true, there can be multiple calls to @ref clingo_control_solve()."]
    #[doc = "!"]
    #[doc = "! @param[in] incremental whether the program is incremental"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub init_program: ::std::option::Option<
        unsafe extern "C" fn(incremental: bool, data: *mut ::std::os::raw::c_void) -> bool,
    >,
    #[doc = "! Marks the beginning of a block of directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @see @ref end_step"]
    #[doc = "!"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub begin_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Marks the end of a block of directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! This function is called before solving starts."]
    #[doc = "!"]
    #[doc = "! @see @ref begin_step"]
    #[doc = "!"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub end_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Observe rules passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] body the body literals"]
    #[doc = "! @param[in] body_size the number of literals in the body"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            body: *const clingo_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe weight rules passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] lower_bound the lower bound of the weight rule"]
    #[doc = "! @param[in] body the weighted body literals"]
    #[doc = "! @param[in] body_size the number of weighted literals in the body"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub weight_rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            lower_bound: clingo_weight_t,
            body: *const clingo_weighted_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe minimize constraints (or weak constraints) passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] priority the priority of the constraint"]
    #[doc = "! @param[in] literals the weighted literals whose sum to minimize"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub minimize: ::std::option::Option<
        unsafe extern "C" fn(
            priority: clingo_weight_t,
            literals: *const clingo_weighted_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe projection directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the atoms to project on"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub project: ::std::option::Option<
        unsafe extern "C" fn(
            atoms: *const clingo_atom_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown atoms passed to the solver."]
    #[doc = "! \\note Facts do not have an associated aspif atom."]
    #[doc = "! The value of the atom is set to zero."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the atom"]
    #[doc = "! @param[in] atom the aspif atom (0 for facts)"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_atom: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            atom: clingo_atom_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown terms passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the term"]
    #[doc = "! @param[in] condition the literals of the condition"]
    #[doc = "! @param[in] size the size of the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_term: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown csp variables passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the variable"]
    #[doc = "! @param[in] value the value of the variable"]
    #[doc = "! @param[in] condition the literals of the condition"]
    #[doc = "! @param[in] size the size of the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_csp: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            value: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe external statements passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atom the external atom"]
    #[doc = "! @param[in] type the type of the external statement"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub external: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_external_type_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe assumption directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub assume: ::std::option::Option<
        unsafe extern "C" fn(
            literals: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe heuristic directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atom the target atom"]
    #[doc = "! @param[in] type the type of the heuristic modification"]
    #[doc = "! @param[in] bias the heuristic bias"]
    #[doc = "! @param[in] priority the heuristic priority"]
    #[doc = "! @param[in] condition the condition under which to apply the heuristic modification"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub heuristic: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_heuristic_type_t,
            bias: ::std::os::raw::c_int,
            priority: ::std::os::raw::c_uint,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe edge directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] node_u the start vertex of the edge"]
    #[doc = "! @param[in] node_v the end vertex of the edge"]
    #[doc = "! @param[in] condition the condition under which the edge is part of the graph"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub acyc_edge: ::std::option::Option<
        unsafe extern "C" fn(
            node_u: ::std::os::raw::c_int,
            node_v: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe numeric theory terms."]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] number the value of the term"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_number: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            number: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe string theory terms."]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] name the value of the term"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_string: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe compound theory terms."]
    #[doc = "!"]
    #[doc = "! The name_id_or_type gives the type of the compound term:"]
    #[doc = "! - if it is -1, then it is a tuple"]
    #[doc = "! - if it is -2, then it is a set"]
    #[doc = "! - if it is -3, then it is a list"]
    #[doc = "! - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term)"]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] name_id_or_type the name or type of the term"]
    #[doc = "! @param[in] arguments the arguments of the term"]
    #[doc = "! @param[in] size the number of arguments"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_compound: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name_id_or_type: ::std::os::raw::c_int,
            arguments: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory elements."]
    #[doc = "!"]
    #[doc = "! @param element_id the id of the element"]
    #[doc = "! @param terms the term tuple of the element"]
    #[doc = "! @param terms_size the number of terms in the tuple"]
    #[doc = "! @param condition the condition of the elemnt"]
    #[doc = "! @param condition_size the number of literals in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_element: ::std::option::Option<
        unsafe extern "C" fn(
            element_id: clingo_id_t,
            terms: *const clingo_id_t,
            terms_size: usize,
            condition: *const clingo_literal_t,
            condition_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms without guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atom_id_or_zero the id of the atom or zero for directives"]
    #[doc = "! @param[in] term_id the term associated with the atom"]
    #[doc = "! @param[in] elements the elements of the atom"]
    #[doc = "! @param[in] size the number of elements"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_atom: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms with guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atom_id_or_zero the id of the atom or zero for directives"]
    #[doc = "! @param[in] term_id the term associated with the atom"]
    #[doc = "! @param[in] elements the elements of the atom"]
    #[doc = "! @param[in] size the number of elements"]
    #[doc = "! @param[in] operator_id the id of the operator (a string term)"]
    #[doc = "! @param[in] right_hand_side_id the id of the term on the right hand side of the atom"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_atom_with_guard: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            operator_id: clingo_id_t,
            right_hand_side_id: clingo_id_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_ground_program_observer() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ground_program_observer>(),
        160usize,
        concat!("Size of: ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ground_program_observer>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).init_program as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(init_program)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).begin_step as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(begin_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).end_step as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(end_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).rule as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).weight_rule as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(weight_rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).minimize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(minimize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).project as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_atom as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_term as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_csp as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_csp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).external as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).assume as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(assume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).heuristic as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).acyc_edge as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(acyc_edge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_number
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_string
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_compound
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_compound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_element as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_atom as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_atom_with_guard
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom_with_guard)
        )
    );
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver."]
#[doc = "!"]
#[doc = "! @note This interface is closely modeled after the aspif format."]
#[doc = "! For more information please refer to the specification of the aspif format."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! If one of the callbacks in the struct fails, grounding is stopped."]
#[doc = "! If a non-recoverable clingo API call fails, a callback must return false."]
#[doc = "! Otherwise ::clingo_error_unknown should be set and false returned."]
#[doc = "!"]
#[doc = "! @see clingo_control_register_observer()"]
pub type clingo_ground_program_observer_t = clingo_ground_program_observer;
#[doc = "! Struct used to specify the program parts that have to be grounded."]
#[doc = "!"]
#[doc = "! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground."]
#[doc = "! Program parts are mainly interesting for incremental grounding and multi-shot solving."]
#[doc = "! For single-shot solving, program parts are not needed."]
#[doc = "!"]
#[doc = "! @note Parts of a logic program without an explicit <tt>\\#program</tt>"]
#[doc = "! specification are by default put into a program called `base` without"]
#[doc = "! arguments."]
#[doc = "!"]
#[doc = "! @see clingo_control_ground()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_part {
    #[doc = "!< name of the program part"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< array of parameters"]
    pub params: *const clingo_symbol_t,
    #[doc = "!< number of parameters"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_part() {
    assert_eq!(
        ::std::mem::size_of::<clingo_part>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_part))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_part>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_part))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct used to specify the program parts that have to be grounded."]
#[doc = "!"]
#[doc = "! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground."]
#[doc = "! Program parts are mainly interesting for incremental grounding and multi-shot solving."]
#[doc = "! For single-shot solving, program parts are not needed."]
#[doc = "!"]
#[doc = "! @note Parts of a logic program without an explicit <tt>\\#program</tt>"]
#[doc = "! specification are by default put into a program called `base` without"]
#[doc = "! arguments."]
#[doc = "!"]
#[doc = "! @see clingo_control_ground()"]
pub type clingo_part_t = clingo_part;
#[doc = "! Callback function to implement external functions."]
#[doc = "!"]
#[doc = "! If an external function of form <tt>\\@name(parameters)</tt> occurs in a logic program,"]
#[doc = "! then this function is called with its location, name, parameters, and a callback to inject symbols as arguments."]
#[doc = "! The callback can be called multiple times; all symbols passed are injected."]
#[doc = "!"]
#[doc = "! If a (non-recoverable) clingo API function fails in this callback, for example, the symbol callback, the callback must return false."]
#[doc = "! In case of errors not related to clingo, this function can set error ::clingo_error_unknown and return false to stop grounding with an error."]
#[doc = "!"]
#[doc = "! @param[in] location location from which the external function was called"]
#[doc = "! @param[in] name name of the called external function"]
#[doc = "! @param[in] arguments arguments of the called external function"]
#[doc = "! @param[in] arguments_size number of arguments"]
#[doc = "! @param[in] data user data of the callback"]
#[doc = "! @param[in] symbol_callback function to inject symbols"]
#[doc = "! @param[in] symbol_callback_data user data for the symbol callback"]
#[doc = "!            (must be passed untouched)"]
#[doc = "! @return whether the call was successful"]
#[doc = "! @see clingo_control_ground()"]
#[doc = "!"]
#[doc = "! The following example implements the external function <tt>\\@f()</tt> returning 42."]
#[doc = "! ~~~~~~~~~~~~~~~{.c}"]
#[doc = "! bool"]
#[doc = "! ground_callback(clingo_location_t const *location,"]
#[doc = "!                 char const *name,"]
#[doc = "!                 clingo_symbol_t const *arguments,"]
#[doc = "!                 size_t arguments_size,"]
#[doc = "!                 void *data,"]
#[doc = "!                 clingo_symbol_callback_t symbol_callback,"]
#[doc = "!                 void *symbol_callback_data) {"]
#[doc = "!   if (strcmp(name, \"f\") == 0 && arguments_size == 0) {"]
#[doc = "!     clingo_symbol_t sym;"]
#[doc = "!     clingo_symbol_create_number(42, &sym);"]
#[doc = "!     return symbol_callback(&sym, 1, symbol_callback_data);"]
#[doc = "!   }"]
#[doc = "!   clingo_set_error(clingo_error_runtime, \"function not found\");"]
#[doc = "!   return false;"]
#[doc = "! }"]
#[doc = "! ~~~~~~~~~~~~~~~"]
pub type clingo_ground_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const clingo_location_t,
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        data: *mut ::std::os::raw::c_void,
        symbol_callback: clingo_symbol_callback_t,
        symbol_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_control {
    _unused: [u8; 0],
}
#[doc = "! Control object holding grounding and solving state."]
pub type clingo_control_t = clingo_control;
extern "C" {
    #[doc = "! Create a new control object."]
    #[doc = "!"]
    #[doc = "! A control object has to be freed using clingo_control_free()."]
    #[doc = "!"]
    #[doc = "! @note Only gringo options (without <code>\\-\\-output</code>) and clasp's options are supported as arguments,"]
    #[doc = "! except basic options such as <code>\\-\\-help</code>."]
    #[doc = "! Furthermore, a control object is blocked while a search call is active;"]
    #[doc = "! you must not call any member function during search."]
    #[doc = "!"]
    #[doc = "! If the logger is NULL, messages are printed to stderr."]
    #[doc = "!"]
    #[doc = "! @param[in] arguments C string array of command line arguments"]
    #[doc = "! @param[in] arguments_size size of the arguments array"]
    #[doc = "! @param[in] logger callback functions for warnings and info messages"]
    #[doc = "! @param[in] logger_data user data for the logger callback"]
    #[doc = "! @param[in] message_limit maximum number of times the logger callback is called"]
    #[doc = "! @param[out] control resulting control object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if argument parsing fails"]
    pub fn clingo_control_new(
        arguments: *const *const ::std::os::raw::c_char,
        arguments_size: usize,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        control: *mut *mut clingo_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Free a control object created with clingo_control_new()."]
    #[doc = "! @param[in] control the target"]
    pub fn clingo_control_free(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Extend the logic program with a program in a file."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] file path to the file"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing or checking fails"]
    pub fn clingo_control_load(
        control: *mut clingo_control_t,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Extend the logic program with the given non-ground logic program in string form."]
    #[doc = "!"]
    #[doc = "! This function puts the given program into a block of form: <tt>\\#program name(parameters).</tt>"]
    #[doc = "!"]
    #[doc = "! After extending the logic program, the corresponding program parts are typically grounded with ::clingo_control_ground."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name name of the program block"]
    #[doc = "! @param[in] parameters string array of parameters of the program block"]
    #[doc = "! @param[in] parameters_size number of parameters"]
    #[doc = "! @param[in] program string representation of the program"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_control_add(
        control: *mut clingo_control_t,
        name: *const ::std::os::raw::c_char,
        parameters: *const *const ::std::os::raw::c_char,
        parameters_size: usize,
        program: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Ground the selected @link ::clingo_part parts @endlink of the current (non-ground) logic program."]
    #[doc = "!"]
    #[doc = "! After grounding, logic programs can be solved with ::clingo_control_solve()."]
    #[doc = "!"]
    #[doc = "! @note Parts of a logic program without an explicit <tt>\\#program</tt>"]
    #[doc = "! specification are by default put into a program called `base` without"]
    #[doc = "! arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] parts array of parts to ground"]
    #[doc = "! @param[in] parts_size size of the parts array"]
    #[doc = "! @param[in] ground_callback callback to implement external functions"]
    #[doc = "! @param[in] ground_callback_data user data for ground_callback"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - error code of ground callback"]
    #[doc = "!"]
    #[doc = "! @see clingo_part"]
    pub fn clingo_control_ground(
        control: *mut clingo_control_t,
        parts: *const clingo_part_t,
        parts_size: usize,
        ground_callback: clingo_ground_callback_t,
        ground_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Solve the currently @link ::clingo_control_ground grounded @endlink logic program enumerating its models."]
    #[doc = "!"]
    #[doc = "! See the @ref SolveHandle module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] mode configures the search mode"]
    #[doc = "! @param[in] assumptions array of assumptions to solve under"]
    #[doc = "! @param[in] assumptions_size number of assumptions"]
    #[doc = "! @param[in] notify the event handler to register"]
    #[doc = "! @param[in] data the user data for the event handler"]
    #[doc = "! @param[out] handle handle to the current search to enumerate models"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving could not be started"]
    pub fn clingo_control_solve(
        control: *mut clingo_control_t,
        mode: clingo_solve_mode_bitset_t,
        assumptions: *const clingo_literal_t,
        assumptions_size: usize,
        notify: clingo_solve_event_callback_t,
        data: *mut ::std::os::raw::c_void,
        handle: *mut *mut clingo_solve_handle_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "!"]
    #[doc = "! @see clingo_control_get_enable_cleanup()"]
    #[doc = "! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Assign a truth value to an external atom."]
    #[doc = "!"]
    #[doc = "! If a negative literal is passed, the corresponding atom is assigned the"]
    #[doc = "! inverted truth value."]
    #[doc = "!"]
    #[doc = "! If the atom does not exist or is not external, this is a noop."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal literal to assign"]
    #[doc = "! @param[in] value the truth value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_assign_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
        value: clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Release an external atom."]
    #[doc = "!"]
    #[doc = "! If a negative literal is passed, the corresponding atom is released."]
    #[doc = "!"]
    #[doc = "! After this call, an external atom is no longer external and subject to"]
    #[doc = "! program simplifications.  If the atom does not exist or is not external,"]
    #[doc = "! this is a noop."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal literal to release"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_release_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a custom propagator with the control object."]
    #[doc = "!"]
    #[doc = "! If the sequential flag is set to true, the propagator is called"]
    #[doc = "! sequentially when solving with multiple threads."]
    #[doc = "!"]
    #[doc = "! See the @ref Propagator module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] propagator the propagator"]
    #[doc = "! @param[in] data user data passed to the propagator functions"]
    #[doc = "! @param[in] sequential whether the propagator should be called sequentially"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_register_propagator(
        control: *mut clingo_control_t,
        propagator: *const clingo_propagator_t,
        data: *mut ::std::os::raw::c_void,
        sequential: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the solver has determined that the internal program representation is conflicting."]
    #[doc = "!"]
    #[doc = "! If this function returns true, solve calls will return immediately with an unsatisfiable solve result."]
    #[doc = "! Note that conflicts first have to be detected, e.g. -"]
    #[doc = "! initial unit propagation results in an empty clause,"]
    #[doc = "! or later if an empty clause is resolved during solving."]
    #[doc = "! Hence, the function might return false even if the problem is unsatisfiable."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return whether the program representation is conflicting"]
    pub fn clingo_control_is_conflicting(control: *const clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Get a statistics object to inspect solver statistics."]
    #[doc = "!"]
    #[doc = "! Statistics are updated after a solve call."]
    #[doc = "!"]
    #[doc = "! See the @ref Statistics module for more information."]
    #[doc = "!"]
    #[doc = "! @attention"]
    #[doc = "! The level of detail of the statistics depends on the stats option"]
    #[doc = "! (which can be set using @ref Configuration module or passed as an option when @link clingo_control_new creating the control object@endlink)."]
    #[doc = "! The default level zero only provides basic statistics,"]
    #[doc = "! level one provides extended and accumulated statistics,"]
    #[doc = "! and level two provides per-thread statistics."]
    #[doc = "! Furthermore, the statistics object is best accessed right after solving."]
    #[doc = "! Otherwise, not all of its entries have valid values."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] statistics the statistics object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_statistics(
        control: *const clingo_control_t,
        statistics: *mut *const clingo_statistics_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Interrupt the active solve call (or the following solve call right at the beginning)."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    pub fn clingo_control_interrupt(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Get low-level access to clasp."]
    #[doc = "!"]
    #[doc = "! @attention"]
    #[doc = "! This function is intended for experimental use only and not part of the stable API."]
    #[doc = "!"]
    #[doc = "! This function may return a <code>nullptr</code>."]
    #[doc = "! Otherwise, the returned pointer can be casted to a ClaspFacade pointer."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] clasp pointer to the ClaspFacade object (may be <code>nullptr</code>)"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_clasp_facade(
        control: *mut clingo_control_t,
        clasp: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a configuration object to change the solver configuration."]
    #[doc = "!"]
    #[doc = "! See the @ref Configuration module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] configuration the configuration object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_configuration(
        control: *mut clingo_control_t,
        configuration: *mut *mut clingo_configuration_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Configure how learnt constraints are handled during enumeration."]
    #[doc = "!"]
    #[doc = "! If the enumeration assumption is enabled, then all information learnt from"]
    #[doc = "! the solver's various enumeration modes is removed after a solve call. This"]
    #[doc = "! includes enumeration of cautious or brave consequences, enumeration of"]
    #[doc = "! answer sets with or without projection, or finding optimal models, as well"]
    #[doc = "! as clauses added with clingo_solve_control_add_clause()."]
    #[doc = "!"]
    #[doc = "! @attention For practical purposes, this option is only interesting for single-shot solving"]
    #[doc = "! or before the last solve call to squeeze out a tiny bit of performance."]
    #[doc = "! Initially, the enumeration assumption is enabled."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] enable whether to enable the assumption"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_set_enable_enumeration_assumption(
        control: *mut clingo_control_t,
        enable: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether the enumeration assumption is enabled."]
    #[doc = "!"]
    #[doc = "! See ::clingo_control_set_enable_enumeration_assumption()."]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return whether using the enumeration assumption is enabled"]
    pub fn clingo_control_get_enable_enumeration_assumption(control: *mut clingo_control_t)
        -> bool;
}
extern "C" {
    #[doc = "! Enable automatic cleanup after solving."]
    #[doc = "!"]
    #[doc = "! @note Cleanup is enabled by default."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] enable whether to enable cleanups"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "!"]
    #[doc = "! @see clingo_control_cleanup()"]
    #[doc = "! @see clingo_control_get_enable_cleanup()"]
    pub fn clingo_control_set_enable_cleanup(control: *mut clingo_control_t, enable: bool) -> bool;
}
extern "C" {
    #[doc = "! Check whether automatic cleanup is enabled."]
    #[doc = "!"]
    #[doc = "! See ::clingo_control_set_enable_cleanup()."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "!"]
    #[doc = "! @see clingo_control_cleanup()"]
    #[doc = "! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_get_enable_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Return the symbol for a constant definition of form: <tt>\\#const name = symbol</tt>."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name the name of the constant"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_get_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if there is a constant definition for the given constant."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name the name of the constant"]
    #[doc = "! @param[out] exists whether a matching constant definition exists"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if constant definition does not exist"]
    #[doc = "!"]
    #[doc = "! @see clingo_control_get_const()"]
    pub fn clingo_control_has_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        exists: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect symbolic atoms (the relevant Herbrand base) used"]
    #[doc = "! for grounding."]
    #[doc = "!"]
    #[doc = "! See the @ref SymbolicAtoms module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the symbolic atoms object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_symbolic_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect theory atoms that occur in the grounding."]
    #[doc = "!"]
    #[doc = "! See the @ref TheoryAtoms module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the theory atoms object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_theory_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a program observer with the control object."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] observer the observer to register"]
    #[doc = "! @param[in] replace just pass the grounding to the observer but not the solver"]
    #[doc = "! @param[in] data user data passed to the observer functions"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_register_observer(
        control: *mut clingo_control_t,
        observer: *const clingo_ground_program_observer_t,
        replace: bool,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to add ground directives to the program."]
    #[doc = "!"]
    #[doc = "! See the @ref ProgramBuilder module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] backend the backend object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_backend(
        control: *mut clingo_control_t,
        backend: *mut *mut clingo_backend_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to add non-ground directives to the program."]
    #[doc = "!"]
    #[doc = "! See the @ref ProgramBuilder module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] builder the program builder object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_program_builder(
        control: *mut clingo_control_t,
        builder: *mut *mut clingo_program_builder_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_options {
    _unused: [u8; 0],
}
#[doc = "! Object to add command-line options."]
pub type clingo_options_t = clingo_options;
#[doc = "! Callback to customize clingo main function."]
#[doc = "!"]
#[doc = "! @param[in] control corresponding control object"]
#[doc = "! @param[in] files files passed via command line arguments"]
#[doc = "! @param[in] size number of files"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_main_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        control: *mut clingo_control_t,
        files: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Callback to print a model in default format."]
#[doc = "!"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_default_model_printer_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
#[doc = "! Callback to customize model printing."]
#[doc = "!"]
#[doc = "! @param[in] model the model"]
#[doc = "! @param[in] printer the default model printer"]
#[doc = "! @param[in] printer_data user data for the printer"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_model_printer_t = ::std::option::Option<
    unsafe extern "C" fn(
        model: *const clingo_model_t,
        printer: clingo_default_model_printer_t,
        printer_data: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! This struct contains a set of functions to customize the clingo application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_application {
    #[doc = "!< callback to obtain program name"]
    pub program_name: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain version information"]
    pub version: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain message limit"]
    pub message_limit: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    >,
    #[doc = "!< callback to override clingo's main function"]
    pub main: clingo_main_function_t,
    #[doc = "!< callback to override default logger"]
    pub logger: clingo_logger_t,
    #[doc = "!< callback to override default model printing"]
    pub printer: clingo_model_printer_t,
    #[doc = "!< callback to register options"]
    pub register_options: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut clingo_options_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "!< callback validate options"]
    pub validate_options:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
}
#[test]
fn bindgen_test_layout_clingo_application() {
    assert_eq!(
        ::std::mem::size_of::<clingo_application>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_application))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_application>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_application))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).program_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(program_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).message_limit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(message_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).main as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).logger as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).printer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(printer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).register_options as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(register_options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).validate_options as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(validate_options)
        )
    );
}
#[doc = "! This struct contains a set of functions to customize the clingo application."]
pub type clingo_application_t = clingo_application;
extern "C" {
    #[doc = "! Add an option that is processed with a custom parser."]
    #[doc = "!"]
    #[doc = "! Note that the parser also has to take care of storing the semantic value of"]
    #[doc = "! the option somewhere."]
    #[doc = "!"]
    #[doc = "! Parameter option specifies the name(s) of the option."]
    #[doc = "! For example, \"ping,p\" adds the short option \"-p\" and its long form \"--ping\"."]
    #[doc = "! It is also possible to associate an option with a help level by adding \",@l\" to the option specification."]
    #[doc = "! Options with a level greater than zero are only shown if the argument to help is greater or equal to l."]
    #[doc = "!"]
    #[doc = "! @param[in] options object to register the option with"]
    #[doc = "! @param[in] group options are grouped into sections as given by this string"]
    #[doc = "! @param[in] option specifies the command line option"]
    #[doc = "! @param[in] description the description of the option"]
    #[doc = "! @param[in] parse callback to parse the value of the option"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @param[in] multi whether the option can appear multiple times on the command-line"]
    #[doc = "! @param[in] argument optional string to change the value name in the generated help output"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_options_add(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                value: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
        multi: bool,
        argument: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an option that is a simple flag."]
    #[doc = "!"]
    #[doc = "! This function is similar to @ref clingo_options_add() but simpler because it only supports flags, which do not have values."]
    #[doc = "! If a flag is passed via the command-line the parameter target is set to true."]
    #[doc = "!"]
    #[doc = "! @param[in] options object to register the option with"]
    #[doc = "! @param[in] group options are grouped into sections as given by this string"]
    #[doc = "! @param[in] option specifies the command line option"]
    #[doc = "! @param[in] description the description of the option"]
    #[doc = "! @param[in] target boolean set to true if the flag is given on the command-line"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_options_add_flag(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        target: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Run clingo with a customized main function (similar to python and lua embedding)."]
    #[doc = "!"]
    #[doc = "! @param[in] application struct with callbacks to override default clingo functionality"]
    #[doc = "! @param[in] arguments command line arguments"]
    #[doc = "! @param[in] size number of arguments"]
    #[doc = "! @param[in] data user data to pass to callbacks in application"]
    #[doc = "! @return exit code to return from main function"]
    pub fn clingo_main(
        application: *mut clingo_application_t,
        arguments: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "! Custom scripting language to run functions during grounding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_script {
    #[doc = "! Evaluate the given source code."]
    #[doc = "! @param[in] location the location in the logic program of the source code"]
    #[doc = "! @param[in] code the code to evaluate"]
    #[doc = "! @param[in] data user data as given when registering the script"]
    #[doc = "! @return whether the function call was successful"]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            location: *const clingo_location_t,
            code: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Call the function with the given name and arguments."]
    #[doc = "! @param[in] location the location in the logic program of the function call"]
    #[doc = "! @param[in] name the name of the function"]
    #[doc = "! @param[in] arguments the arguments to the function"]
    #[doc = "! @param[in] arguments_size the number of arguments"]
    #[doc = "! @param[in] symbol_callback callback to return a pool of symbols"]
    #[doc = "! @param[in] symbol_callback_data user data for the symbol callback"]
    #[doc = "! @param[in] data user data as given when registering the script"]
    #[doc = "! @return whether the function call was successful"]
    pub call: ::std::option::Option<
        unsafe extern "C" fn(
            location: *const clingo_location_t,
            name: *const ::std::os::raw::c_char,
            arguments: *const clingo_symbol_t,
            arguments_size: usize,
            symbol_callback: clingo_symbol_callback_t,
            symbol_callback_data: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Check if the given function is callable."]
    #[doc = "! @param[in] name the name of the function"]
    #[doc = "! @param[out] result whether the function is callable"]
    #[doc = "! @param[in] data user data as given when registering the script"]
    #[doc = "! @return whether the function call was successful"]
    pub callable: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            result: *mut bool,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Run the main function."]
    #[doc = "! @param[in] control the control object to pass to the main function"]
    #[doc = "! @param[in] data user data as given when registering the script"]
    #[doc = "! @return whether the function call was successful"]
    pub main: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function is called once when the script is deleted."]
    #[doc = "! @param[in] data user data as given when registering the script"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub version: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_script() {
    assert_eq!(
        ::std::mem::size_of::<clingo_script>(),
        48usize,
        concat!("Size of: ", stringify!(clingo_script))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_script>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_script))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).execute as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).call as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(call)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).callable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(callable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).main as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_script>())).version as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(version)
        )
    );
}
#[doc = "! Custom scripting language to run functions during grounding."]
pub type clingo_script_t = clingo_script;
extern "C" {
    #[doc = "! Add a custom scripting language to clingo."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name of the scripting language"]
    #[doc = "! @param[in] script struct with functions implementing the language"]
    #[doc = "! @param[in] data user data to pass to callbacks in the script"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_register_script(
        name: *const ::std::os::raw::c_char,
        script: *const clingo_script_t,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the version of the registered scripting language."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name of the scripting language"]
    #[doc = "! @return the version"]
    pub fn clingo_script_version(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
