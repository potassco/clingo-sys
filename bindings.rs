/* automatically generated by rust-bindgen 0.68.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CLINGO_VERSION_MAJOR: u32 = 5;
pub const CLINGO_VERSION_MINOR: u32 = 7;
pub const CLINGO_VERSION_REVISION: u32 = 0;
pub const CLINGO_VERSION: &[u8; 6] = b"5.7.0\0";
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "! Signed integer type used for aspif and solver literals."]
pub type clingo_literal_t = i32;
#[doc = "! Unsigned integer type used for aspif atoms."]
pub type clingo_atom_t = u32;
#[doc = "! Unsigned integer type used in various places."]
pub type clingo_id_t = u32;
#[doc = "! Signed integer type for weights in sum aggregates and minimize constraints."]
pub type clingo_weight_t = i32;
#[doc = "! A Literal with an associated weight."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_weighted_literal {
    pub literal: clingo_literal_t,
    pub weight: clingo_weight_t,
}
#[test]
fn bindgen_test_layout_clingo_weighted_literal() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_weighted_literal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_weighted_literal>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_weighted_literal>(),
        4usize,
        concat!("Alignment of ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).literal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(weight)
        )
    );
}
#[doc = "! A Literal with an associated weight."]
pub type clingo_weighted_literal_t = clingo_weighted_literal;
#[doc = "!< successful API calls"]
pub const clingo_error_e_clingo_error_success: clingo_error_e = 0;
#[doc = "!< errors only detectable at runtime like invalid input"]
pub const clingo_error_e_clingo_error_runtime: clingo_error_e = 1;
#[doc = "!< wrong usage of the clingo API"]
pub const clingo_error_e_clingo_error_logic: clingo_error_e = 2;
#[doc = "!< memory could not be allocated"]
pub const clingo_error_e_clingo_error_bad_alloc: clingo_error_e = 3;
#[doc = "!< errors unrelated to clingo"]
pub const clingo_error_e_clingo_error_unknown: clingo_error_e = 4;
#[doc = "! Enumeration of error codes.\n!\n! @note Errors can only be recovered from if explicitly mentioned; most\n! functions do not provide strong exception guarantees.  This means that in\n! case of errors associated objects cannot be used further.  If such an\n! object has a free function, this function can and should still be called."]
pub type clingo_error_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_error_e."]
pub type clingo_error_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert error code into string."]
    pub fn clingo_error_string(code: clingo_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the last error code set by a clingo API call.\n! @note Each thread has its own local error code.\n! @return error code"]
    pub fn clingo_error_code() -> clingo_error_t;
}
extern "C" {
    #[doc = "! Get the last error message set if an API call fails.\n! @note Each thread has its own local error message.\n! @return error message or NULL"]
    pub fn clingo_error_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Set a custom error code and message in the active thread.\n! @param[in] code the error code\n! @param[in] message the error message"]
    pub fn clingo_set_error(code: clingo_error_t, message: *const ::std::os::raw::c_char);
}
#[doc = "!< undefined arithmetic operation or weight of aggregate"]
pub const clingo_warning_e_clingo_warning_operation_undefined: clingo_warning_e = 0;
#[doc = "!< to report multiple errors; a corresponding runtime error is raised later"]
pub const clingo_warning_e_clingo_warning_runtime_error: clingo_warning_e = 1;
#[doc = "!< undefined atom in program"]
pub const clingo_warning_e_clingo_warning_atom_undefined: clingo_warning_e = 2;
#[doc = "!< same file included multiple times"]
pub const clingo_warning_e_clingo_warning_file_included: clingo_warning_e = 3;
#[doc = "!< CSP variable with unbounded domain"]
pub const clingo_warning_e_clingo_warning_variable_unbounded: clingo_warning_e = 4;
#[doc = "!< global variable in tuple of aggregate element"]
pub const clingo_warning_e_clingo_warning_global_variable: clingo_warning_e = 5;
#[doc = "!< other kinds of warnings"]
pub const clingo_warning_e_clingo_warning_other: clingo_warning_e = 6;
#[doc = "! Enumeration of warning codes."]
pub type clingo_warning_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_warning_e."]
pub type clingo_warning_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert warning code into string."]
    pub fn clingo_warning_string(code: clingo_warning_t) -> *const ::std::os::raw::c_char;
}
#[doc = "! Callback to intercept warning messages.\n!\n! @param[in] code associated warning code\n! @param[in] message warning message\n! @param[in] data user data for callback\n!\n! @see clingo_control_new()\n! @see clingo_parse_term()\n! @see clingo_parse_program()"]
pub type clingo_logger_t = ::std::option::Option<
    unsafe extern "C" fn(
        code: clingo_warning_t,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "! Obtain the clingo version.\n!\n! @param[out] major major version number\n! @param[out] minor minor version number\n! @param[out] revision revision number"]
    pub fn clingo_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        revision: *mut ::std::os::raw::c_int,
    );
}
#[doc = "!< no truth value"]
pub const clingo_truth_value_e_clingo_truth_value_free: clingo_truth_value_e = 0;
#[doc = "!< true"]
pub const clingo_truth_value_e_clingo_truth_value_true: clingo_truth_value_e = 1;
#[doc = "!< false"]
pub const clingo_truth_value_e_clingo_truth_value_false: clingo_truth_value_e = 2;
#[doc = "! Represents three-valued truth values."]
pub type clingo_truth_value_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_truth_value_e."]
pub type clingo_truth_value_t = ::std::os::raw::c_int;
#[doc = "! Represents a source code location marking its beginnig and end.\n!\n! @note Not all locations refer to physical files.\n! By convention, such locations use a name put in angular brackets as filename.\n! The string members of a location object are internalized and valid for the duration of the process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_location {
    #[doc = "!< the file where the location begins"]
    pub begin_file: *const ::std::os::raw::c_char,
    #[doc = "!< the file where the location ends"]
    pub end_file: *const ::std::os::raw::c_char,
    #[doc = "!< the line where the location begins"]
    pub begin_line: usize,
    #[doc = "!< the line where the location ends"]
    pub end_line: usize,
    #[doc = "!< the column where the location begins"]
    pub begin_column: usize,
    #[doc = "!< the column where the location ends"]
    pub end_column: usize,
}
#[test]
fn bindgen_test_layout_clingo_location() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_location> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_location>(),
        48usize,
        concat!("Size of: ", stringify!(clingo_location))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_location>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_location))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_line) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_column) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_column) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_column)
        )
    );
}
#[doc = "! Represents a source code location marking its beginnig and end.\n!\n! @note Not all locations refer to physical files.\n! By convention, such locations use a name put in angular brackets as filename.\n! The string members of a location object are internalized and valid for the duration of the process."]
pub type clingo_location_t = clingo_location;
#[doc = "! Represents a predicate signature.\n!\n! Signatures have a name and an arity, and can be positive or negative (to\n! represent classical negation)."]
pub type clingo_signature_t = u64;
extern "C" {
    #[doc = "! Create a new signature.\n!\n! @param[in] name name of the signature\n! @param[in] arity arity of the signature\n! @param[in] positive false if the signature has a classical negation sign\n! @param[out] signature the resulting signature\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_signature_create(
        name: *const ::std::os::raw::c_char,
        arity: u32,
        positive: bool,
        signature: *mut clingo_signature_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a signature.\n!\n! @note\n! The string is internalized and valid for the duration of the process.\n!\n! @param[in] signature the target signature\n! @return the name of the signature"]
    pub fn clingo_signature_name(signature: clingo_signature_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the arity of a signature.\n!\n! @param[in] signature the target signature\n! @return the arity of the signature"]
    pub fn clingo_signature_arity(signature: clingo_signature_t) -> u32;
}
extern "C" {
    #[doc = "! Whether the signature is positive (is not classically negated).\n!\n! @param[in] signature the target signature\n! @return whether the signature has no sign"]
    pub fn clingo_signature_is_positive(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Whether the signature is negative (is classically negated).\n!\n! @param[in] signature the target signature\n! @return whether the signature has a sign"]
    pub fn clingo_signature_is_negative(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if two signatures are equal.\n!\n! @param[in] a first signature\n! @param[in] b second signature\n! @return whether a == b"]
    pub fn clingo_signature_is_equal_to(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a signature is less than another signature.\n!\n! Signatures are compared first by sign (unsigned < signed), then by arity,\n! then by name.\n!\n! @param[in] a first signature\n! @param[in] b second signature\n! @return whether a < b"]
    pub fn clingo_signature_is_less_than(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a signature.\n!\n! @param[in] signature the target signature\n! @return the hash code of the signature"]
    pub fn clingo_signature_hash(signature: clingo_signature_t) -> usize;
}
#[doc = "!< the <tt>\\#inf</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_infimum: clingo_symbol_type_e = 0;
#[doc = "!< a numeric symbol, e.g., `1`"]
pub const clingo_symbol_type_e_clingo_symbol_type_number: clingo_symbol_type_e = 1;
#[doc = "!< a string symbol, e.g., `\"a\"`"]
pub const clingo_symbol_type_e_clingo_symbol_type_string: clingo_symbol_type_e = 4;
#[doc = "!< a numeric symbol, e.g., `c`, `(1, \"a\")`, or `f(1,\"a\")`"]
pub const clingo_symbol_type_e_clingo_symbol_type_function: clingo_symbol_type_e = 5;
#[doc = "!< the <tt>\\#sup</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_supremum: clingo_symbol_type_e = 7;
#[doc = "! Enumeration of available symbol types."]
pub type clingo_symbol_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_symbol_type."]
pub type clingo_symbol_type_t = ::std::os::raw::c_int;
#[doc = "! Represents a symbol.\n!\n! This includes numbers, strings, functions (including constants when\n! arguments are empty and tuples when the name is empty), <tt>\\#inf</tt> and <tt>\\#sup</tt>."]
pub type clingo_symbol_t = u64;
extern "C" {
    #[doc = "! Construct a symbol representing a number.\n!\n! @param[in] number the number\n! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_number(number: ::std::os::raw::c_int, symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing \\#sup.\n!\n! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_supremum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing <tt>\\#inf</tt>.\n!\n! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_infimum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing a string.\n!\n! @param[in] string the string\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_string(
        string: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing an id.\n!\n! @note This is just a shortcut for clingo_symbol_create_function() with\n! empty arguments.\n!\n! @param[in] name the name\n! @param[in] positive whether the symbol has a classical negation sign\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_id(
        name: *const ::std::os::raw::c_char,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing a function or tuple.\n!\n! @note To create tuples, the empty string has to be used as name.\n!\n! @param[in] name the name of the function\n! @param[in] arguments the arguments of the function\n! @param[in] arguments_size the number of arguments\n! @param[in] positive whether the symbol has a classical negation sign\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_function(
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of a symbol.\n!\n! @param[in] symbol the target symbol\n! @param[out] number the resulting number\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_number"]
    pub fn clingo_symbol_number(
        symbol: clingo_symbol_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a symbol.\n!\n! @note\n! The string is internalized and valid for the duration of the process.\n!\n! @param[in] symbol the target symbol\n! @param[out] name the resulting name\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_name(
        symbol: clingo_symbol_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string of a symbol.\n!\n! @note\n! The string is internalized and valid for the duration of the process.\n!\n! @param[in] symbol the target symbol\n! @param[out] string the resulting string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_string"]
    pub fn clingo_symbol_string(
        symbol: clingo_symbol_t,
        string: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is positive (does not have a sign).\n!\n! @param[in] symbol the target symbol\n! @param[out] positive the result\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_positive(symbol: clingo_symbol_t, positive: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is negative (has a sign).\n!\n! @param[in] symbol the target symbol\n! @param[out] negative the result\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_negative(symbol: clingo_symbol_t, negative: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of a symbol.\n!\n! @param[in] symbol the target symbol\n! @param[out] arguments the resulting arguments\n! @param[out] arguments_size the number of arguments\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_arguments(
        symbol: clingo_symbol_t,
        arguments: *mut *const clingo_symbol_t,
        arguments_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a symbol.\n!\n! @param[in] symbol the target symbol\n! @return the type of the symbol"]
    pub fn clingo_symbol_type(symbol: clingo_symbol_t) -> clingo_symbol_type_t;
}
extern "C" {
    #[doc = "! Get the size of the string representation of a symbol (including the terminating 0).\n!\n! @param[in] symbol the target symbol\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_to_string_size(symbol: clingo_symbol_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of a symbol.\n!\n! @param[in] symbol the target symbol\n! @param[out] string the resulting string\n! @param[in] size the size of the string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n!\n! @see clingo_symbol_to_string_size()"]
    pub fn clingo_symbol_to_string(
        symbol: clingo_symbol_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two symbols are equal.\n!\n! @param[in] a first symbol\n! @param[in] b second symbol\n! @return whether a == b"]
    pub fn clingo_symbol_is_equal_to(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a symbol is less than another symbol.\n!\n! Symbols are first compared by type.  If the types are equal, the values are\n! compared (where strings are compared using strcmp).  Functions are first\n! compared by signature and then lexicographically by arguments.\n!\n! @param[in] a first symbol\n! @param[in] b second symbol\n! @return whether a < b"]
    pub fn clingo_symbol_is_less_than(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a symbol.\n!\n! @param[in] symbol the target symbol\n! @return the hash code of the symbol"]
    pub fn clingo_symbol_hash(symbol: clingo_symbol_t) -> usize;
}
extern "C" {
    #[doc = "! Internalize a string.\n!\n! This functions takes a string as input and returns an equal unique string\n! that is (at the moment) not freed until the program is closed.\n!\n! @param[in] string the string to internalize\n! @param[out] result the internalized string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_add_string(
        string: *const ::std::os::raw::c_char,
        result: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Parse a term in string form.\n!\n! The result of this function is a symbol. The input term can contain\n! unevaluated functions, which are evaluated during parsing.\n!\n! @param[in] string the string to parse\n! @param[in] logger optional logger to report warnings during parsing\n! @param[in] logger_data user data for the logger\n! @param[in] message_limit maximum number of times to call the logger\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_parse_term(
        string: *const ::std::os::raw::c_char,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_symbolic_atoms {
    _unused: [u8; 0],
}
#[doc = "! Object to inspect symbolic atoms in a program---the relevant Herbrand base\n! gringo uses to instantiate programs.\n!\n! @see clingo_control_symbolic_atoms()"]
pub type clingo_symbolic_atoms_t = clingo_symbolic_atoms;
#[doc = "! Object to iterate over symbolic atoms.\n!\n! Such an iterator either points to a symbolic atom within a sequence of\n! symbolic atoms or to the end of the sequence.\n!\n! @note Iterators are valid as long as the underlying sequence is not modified.\n! Operations that can change this sequence are ::clingo_control_ground(),\n! ::clingo_control_cleanup(), and functions that modify the underlying\n! non-ground program."]
pub type clingo_symbolic_atom_iterator_t = u64;
extern "C" {
    #[doc = "! Get the number of different atoms occurring in a logic program.\n!\n! @param[in] atoms the target\n! @param[out] size the number of atoms\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a forward iterator to the beginning of the sequence of all symbolic\n! atoms optionally restricted to a given signature.\n!\n! @param[in] atoms the target\n! @param[in] signature optional signature\n! @param[out] iterator the resulting iterator\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_begin(
        atoms: *const clingo_symbolic_atoms_t,
        signature: *const clingo_signature_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Iterator pointing to the end of the sequence of symbolic atoms.\n!\n! @param[in] atoms the target\n! @param[out] iterator the resulting iterator\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_end(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Find a symbolic atom given its symbolic representation.\n!\n! @param[in] atoms the target\n! @param[in] symbol the symbol to lookup\n! @param[out] iterator iterator pointing to the symbolic atom or to the end\n! of the sequence if no corresponding atom is found\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_find(
        atoms: *const clingo_symbolic_atoms_t,
        symbol: clingo_symbol_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two iterators point to the same element (or end of the sequence).\n!\n! @param[in] atoms the target\n! @param[in] a the first iterator\n! @param[in] b the second iterator\n! @param[out] equal whether the two iterators are equal\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_iterator_is_equal_to(
        atoms: *const clingo_symbolic_atoms_t,
        a: clingo_symbolic_atom_iterator_t,
        b: clingo_symbolic_atom_iterator_t,
        equal: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbolic representation of an atom.\n!\n! @param[in] atoms the target\n! @param[in] iterator iterator to the atom\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_symbol(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is a fact.\n!\n! @note This does not determine if an atom is a cautious consequence. The\n! grounding or solving component's simplifications can only detect this in\n! some cases.\n!\n! @param[in] atoms the target\n! @param[in] iterator iterator to the atom\n! @param[out] fact whether the atom is a fact\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_fact(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        fact: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is external.\n!\n! An atom is external if it has been defined using an external directive and\n! has not been released or defined by a rule.\n!\n! @param[in] atoms the target\n! @param[in] iterator iterator to the atom\n! @param[out] external whether the atom is a external\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_external(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        external: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the (numeric) aspif literal corresponding to the given symbolic atom.\n!\n! Such a literal can be mapped to a solver literal (see the \\ref Propagator\n! module) or be used in rules in aspif format (see the \\ref ProgramBuilder\n! module).\n!\n! @param[in] atoms the target\n! @param[in] iterator iterator to the atom\n! @param[out] literal the associated literal\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_literal(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of different predicate signatures used in the program.\n!\n! @param[in] atoms the target\n! @param[out] size the number of signatures\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_signatures_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the predicate signatures occurring in a logic program.\n!\n! @param[in] atoms the target\n! @param[out] signatures the resulting signatures\n! @param[in] size the number of signatures\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_symbolic_atoms_signatures_size()"]
    pub fn clingo_symbolic_atoms_signatures(
        atoms: *const clingo_symbolic_atoms_t,
        signatures: *mut clingo_signature_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an iterator to the next element in the sequence of symbolic atoms.\n!\n! @param[in] atoms the target\n! @param[in] iterator the current iterator\n! @param[out] next the succeeding iterator\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_next(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        next: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether the given iterator points to some element with the sequence\n! of symbolic atoms or to the end of the sequence.\n!\n! @param[in] atoms the target\n! @param[in] iterator the iterator\n! @param[out] valid whether the iterator points to some element within the\n! sequence\n! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_valid(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        valid: *mut bool,
    ) -> bool;
}
#[doc = "! Callback function to inject symbols.\n!\n! @param symbols array of symbols\n! @param symbols_size size of the symbol array\n! @param data user data of the callback\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! @see ::clingo_ground_callback_t"]
pub type clingo_symbol_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        symbols: *const clingo_symbol_t,
        symbols_size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "!< a tuple term, e.g., `(1,2,3)`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_tuple: clingo_theory_term_type_e = 0;
#[doc = "!< a list term, e.g., `[1,2,3]`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_list: clingo_theory_term_type_e = 1;
#[doc = "!< a set term, e.g., `{1,2,3}`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_set: clingo_theory_term_type_e = 2;
#[doc = "!< a function term, e.g., `f(1,2,3)`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_function: clingo_theory_term_type_e = 3;
#[doc = "!< a number term, e.g., `42`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_number: clingo_theory_term_type_e = 4;
#[doc = "!< a symbol term, e.g., `c`"]
pub const clingo_theory_term_type_e_clingo_theory_term_type_symbol: clingo_theory_term_type_e = 5;
#[doc = "! Enumeration of theory term types."]
pub type clingo_theory_term_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_theory_term_type_e."]
pub type clingo_theory_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_theory_atoms {
    _unused: [u8; 0],
}
#[doc = "! Container that stores theory atoms, elements, and terms (see @ref clingo_control_theory_atoms())."]
pub type clingo_theory_atoms_t = clingo_theory_atoms;
extern "C" {
    #[doc = "! Get the type of the given theory term.\n!\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] type the resulting type\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_type(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        type_: *mut clingo_theory_term_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of the given numeric theory term.\n!\n! @pre The term must be of type ::clingo_theory_term_type_number.\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] number the resulting number\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_number(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of the given constant or function theory term.\n!\n! @note\n! The lifetime of the string is tied to the current solve step.\n!\n! @pre The term must be of type ::clingo_theory_term_type_function or ::clingo_theory_term_type_symbol.\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] name the resulting name\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_name(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of the given function theory term.\n!\n! @pre The term must be of type ::clingo_theory_term_type_function.\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] arguments the resulting arguments in form of an array of term ids\n! @param[out] size the number of arguments\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_arguments(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        arguments: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory term (including the terminating 0).\n!\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_term_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory term.\n!\n! @param[in] atoms container where the term is stored\n! @param[in] term id of the term\n! @param[out] string the resulting string\n! @param[in] size the size of the string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if the size is too small\n! - ::clingo_error_bad_alloc\n!\n! @see clingo_theory_atoms_term_to_string_size()"]
    pub fn clingo_theory_atoms_term_to_string(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the tuple (array of theory terms) of the given theory element.\n!\n! @param[in] atoms container where the element is stored\n! @param[in] element id of the element\n! @param[out] tuple the resulting array of term ids\n! @param[out] size the number of term ids\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_tuple(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        tuple: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the condition (array of aspif literals) of the given theory element.\n!\n! @param[in] atoms container where the element is stored\n! @param[in] element id of the element\n! @param[out] condition the resulting array of aspif literals\n! @param[out] size the number of term literals\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the condition of the given theory element.\n!\n! @note\n! This id can be mapped to a solver literal using clingo_propagate_init_solver_literal().\n! This id is not (necessarily) an aspif literal;\n! to get aspif literals use clingo_theory_atoms_element_condition().\n!\n! @param[in] atoms container where the element is stored\n! @param[in] element id of the element\n! @param[out] condition the resulting condition id\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition_id(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory element (including the terminating 0).\n!\n! @param[in] atoms container where the element is stored\n! @param[in] element id of the element\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory element.\n!\n! @param[in] atoms container where the element is stored\n! @param[in] element id of the element\n! @param[out] string the resulting string\n! @param[in] size the size of the string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if the size is too small\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the total number of theory atoms.\n!\n! @param[in] atoms the target\n! @param[out] size the resulting number\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_size(atoms: *const clingo_theory_atoms_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the theory term associated with the theory atom.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the atom\n! @param[out] term the resulting term id\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_term(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the theory elements associated with the theory atom.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the atom\n! @param[out] elements the resulting array of elements\n! @param[out] size the number of elements\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_elements(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        elements: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Whether the theory atom has a guard.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the atom\n! @param[out] has_guard whether the theory atom has a guard\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_has_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        has_guard: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the guard consisting of a theory operator and a theory term of the given theory atom.\n!\n! @note\n! The lifetime of the string is tied to the current solve step.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the atom\n! @param[out] connective the resulting theory operator\n! @param[out] term the resulting term\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        connective: *mut *const ::std::os::raw::c_char,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the aspif literal associated with the given theory atom.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the atom\n! @param[out] literal the resulting literal\n! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_literal(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory atom (including the terminating 0).\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the element\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory atom.\n!\n! @param[in] atoms container where the atom is stored\n! @param[in] atom id of the element\n! @param[out] string the resulting string\n! @param[in] size the size of the string\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if the size is too small\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_assignment {
    _unused: [u8; 0],
}
#[doc = "! Represents a (partial) assignment of a particular solver.\n!\n! An assignment assigns truth values to a set of literals.\n! A literal is assigned to either @link clingo_assignment_truth_value() true or false, or is unassigned@endlink.\n! Furthermore, each assigned literal is associated with a @link clingo_assignment_level() decision level@endlink.\n! There is exactly one @link clingo_assignment_decision() decision literal@endlink for each decision level greater than zero.\n! Assignments to all other literals on the same level are consequences implied by the current and possibly previous decisions.\n! Assignments on level zero are immediate consequences of the current program.\n! Decision levels are consecutive numbers starting with zero up to and including the @link clingo_assignment_decision_level() current decision level@endlink."]
pub type clingo_assignment_t = clingo_assignment;
extern "C" {
    #[doc = "! Get the current decision level.\n!\n! @param[in] assignment the target assignment\n! @return the decision level"]
    pub fn clingo_assignment_decision_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Get the current root level.\n!\n! Decisions levels smaller or equal to the root level are not backtracked during solving.\n!\n! @param[in] assignment the target assignment\n! @return the decision level"]
    pub fn clingo_assignment_root_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Check if the given assignment is conflicting.\n!\n! @param[in] assignment the target assignment\n! @return whether the assignment is conflicting"]
    pub fn clingo_assignment_has_conflict(assignment: *const clingo_assignment_t) -> bool;
}
extern "C" {
    #[doc = "! Check if the given literal is part of a (partial) assignment.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @return whether the literal is valid"]
    pub fn clingo_assignment_has_literal(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision level of a given literal.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @param[out] level the resulting level\n! @return whether the call was successful"]
    pub fn clingo_assignment_level(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        level: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision literal given a decision level.\n!\n! @param[in] assignment the target assignment\n! @param[in] level the level\n! @param[out] literal the resulting literal\n! @return whether the call was successful"]
    pub fn clingo_assignment_decision(
        assignment: *const clingo_assignment_t,
        level: u32,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @param[out] is_fixed whether the literal is fixed\n! @return whether the call was successful"]
    pub fn clingo_assignment_is_fixed(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_fixed: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal is true.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @param[out] is_true whether the literal is true\n! @return whether the call was successful\n! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_true(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_true: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @param[out] is_false whether the literal is false\n! @return whether the call was successful\n! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_false(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_false: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the truth value of a given literal.\n!\n! @param[in] assignment the target assignment\n! @param[in] literal the literal\n! @param[out] value the resulting truth value\n! @return whether the call was successful"]
    pub fn clingo_assignment_truth_value(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        value: *mut clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! The number of (positive) literals in the assignment.\n!\n! @param[in] assignment the target\n! @return the number of literals"]
    pub fn clingo_assignment_size(assignment: *const clingo_assignment_t) -> usize;
}
extern "C" {
    #[doc = "! The (positive) literal at the given offset in the assignment.\n!\n! @param[in] assignment the target\n! @param[in] offset the offset of the literal\n! @param[out] literal the literal\n! @return whether the call was successful"]
    pub fn clingo_assignment_at(
        assignment: *const clingo_assignment_t,
        offset: usize,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the assignment is total, i.e. there are no free literal.\n!\n! @param[in] assignment the target\n! @return wheather the assignment is total"]
    pub fn clingo_assignment_is_total(assignment: *const clingo_assignment_t) -> bool;
}
extern "C" {
    #[doc = "! Returns the number of literals in the trail, i.e., the number of assigned literals.\n!\n! @param[in] assignment the target\n! @param[out] size the number of literals in the trail\n! @return whether the call was successful"]
    pub fn clingo_assignment_trail_size(
        assignment: *const clingo_assignment_t,
        size: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the offset of the decision literal with the given decision level in\n! the trail.\n!\n! @note Literals in the trail are ordered by decision levels, where the first\n! literal with a larger level than the previous literals is a decision; the\n! following literals with same level are implied by this decision literal.\n! Each decision level up to and including the current decision level has a\n! valid offset in the trail.\n!\n! @param[in] assignment the target\n! @param[in] level the decision level\n! @param[out] offset the offset of the decision literal\n! @return whether the call was successful"]
    pub fn clingo_assignment_trail_begin(
        assignment: *const clingo_assignment_t,
        level: u32,
        offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the offset following the last literal with the given decision level.\n!\n! @note This function is the counter part to clingo_assignment_trail_begin().\n!\n! @param[in] assignment the target\n! @param[in] level the decision level\n! @param[out] offset the offset\n! @return whether the call was successful"]
    pub fn clingo_assignment_trail_end(
        assignment: *const clingo_assignment_t,
        level: u32,
        offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the literal at the given position in the trail.\n!\n! @param[in] assignment the target\n! @param[in] offset the offset of the literal\n! @param[out] literal the literal\n! @return whether the call was successful"]
    pub fn clingo_assignment_trail_at(
        assignment: *const clingo_assignment_t,
        offset: u32,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
#[doc = "!< do not call @ref ::clingo_propagator::check() at all"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_none:
    clingo_propagator_check_mode_e = 0;
#[doc = "!< call @ref ::clingo_propagator::check() on total assignments"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_total:
    clingo_propagator_check_mode_e = 1;
#[doc = "!< call @ref ::clingo_propagator::check() on propagation fixpoints"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_fixpoint:
    clingo_propagator_check_mode_e = 2;
#[doc = "!< call @ref ::clingo_propagator::check() on propagation fixpoints and total assignments"]
pub const clingo_propagator_check_mode_e_clingo_propagator_check_mode_both:
    clingo_propagator_check_mode_e = 3;
#[doc = "! Supported check modes for propagators.\n!\n! Note that total checks are subject to the lock when a model is found.\n! This means that information from previously found models can be used to discard assignments in check calls."]
pub type clingo_propagator_check_mode_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_propagator_check_mode_e."]
pub type clingo_propagator_check_mode_t = ::std::os::raw::c_int;
#[doc = "!< call @ref ::clingo_propagator::undo() for non-empty change lists"]
pub const clingo_propagator_undo_mode_e_clingo_propagator_undo_mode_default:
    clingo_propagator_undo_mode_e = 0;
#[doc = "!< also call @ref ::clingo_propagator::check() when check has been called"]
pub const clingo_propagator_undo_mode_e_clingo_propagator_undo_mode_always:
    clingo_propagator_undo_mode_e = 1;
#[doc = "! Undo modes for propagators."]
pub type clingo_propagator_undo_mode_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_propagator_undo_mode_e."]
pub type clingo_propagator_undo_mode_t = ::std::os::raw::c_int;
#[doc = "!< the weight constraint implies the literal"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_implication_left:
    clingo_weight_constraint_type_e = -1;
#[doc = "!< the literal implies the weight constraint"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_implication_right:
    clingo_weight_constraint_type_e = 1;
#[doc = "!< the weight constraint is equivalent to the literal"]
pub const clingo_weight_constraint_type_e_clingo_weight_constraint_type_equivalence:
    clingo_weight_constraint_type_e = 0;
#[doc = "! Enumeration of weight_constraint_types."]
pub type clingo_weight_constraint_type_e = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_weight_constraint_type_e."]
pub type clingo_weight_constraint_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_init {
    _unused: [u8; 0],
}
#[doc = "! Object to initialize a user-defined propagator before each solving step.\n!\n! Each @link SymbolicAtoms symbolic@endlink or @link TheoryAtoms theory atom@endlink is uniquely associated with an aspif atom in form of a positive integer (@ref ::clingo_literal_t).\n! Aspif literals additionally are signed to represent default negation.\n! Furthermore, there are non-zero integer solver literals (also represented using @ref ::clingo_literal_t).\n! There is a surjective mapping from program atoms to solver literals.\n!\n! All methods called during propagation use solver literals whereas clingo_symbolic_atoms_literal() and clingo_theory_atoms_atom_literal() return program literals.\n! The function clingo_propagate_init_solver_literal() can be used to map program literals or @link clingo_theory_atoms_element_condition_id() condition ids@endlink to solver literals."]
pub type clingo_propagate_init_t = clingo_propagate_init;
extern "C" {
    #[doc = "! Map the given program literal or condition id to its solver literal.\n!\n! @param[in] init the target\n! @param[in] aspif_literal the aspif literal to map\n! @param[out] solver_literal the resulting solver literal\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_solver_literal(
        init: *const clingo_propagate_init_t,
        aspif_literal: clingo_literal_t,
        solver_literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase.\n!\n! @param[in] init the target\n! @param[in] solver_literal the solver literal\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase to the given solver thread.\n!\n! @param[in] init the target\n! @param[in] solver_literal the solver literal\n! @param[in] thread_id the id of the solver thread\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch_to_thread(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
        thread_id: clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove the watch for the solver literal in the given phase.\n!\n! @param[in] init the target\n! @param[in] solver_literal the solver literal\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_remove_watch(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove the watch for the solver literal in the given phase from the given solver thread.\n!\n! @param[in] init the target\n! @param[in] solver_literal the solver literal\n! @param[in] thread_id the id of the solver thread\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_remove_watch_from_thread(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
        thread_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Freeze the given solver literal.\n!\n! Any solver literal that is not frozen is subject to simplification and might be removed in a preprocessing step after propagator initialization.\n! A propagator should freeze all literals over which it might add clauses during propagation.\n! Note that any watched literal is automatically frozen and that it does not matter which phase of the literal is frozen.\n!\n! @param[in] init the target\n! @param[in] solver_literal the solver literal\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_freeze_literal(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms.\n!\n! @param[in] init the target\n! @param[out] atoms the resulting object\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_symbolic_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the theory atoms.\n!\n! @param[in] init the target\n! @param[out] atoms the resulting object\n! @return whether the call was successful"]
    pub fn clingo_propagate_init_theory_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of threads used in subsequent solving.\n!\n! @param[in] init the target\n! @return the number of threads\n! @see clingo_propagate_control_thread_id()"]
    pub fn clingo_propagate_init_number_of_threads(
        init: *const clingo_propagate_init_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! Configure when to call the check method of the propagator.\n!\n! @param[in] init the target\n! @param[in] mode bitmask when to call the propagator\n! @see @ref ::clingo_propagator::check()"]
    pub fn clingo_propagate_init_set_check_mode(
        init: *mut clingo_propagate_init_t,
        mode: clingo_propagator_check_mode_t,
    );
}
extern "C" {
    #[doc = "! Get the current check mode of the propagator.\n!\n! @param[in] init the target\n! @see clingo_propagate_init_set_check_mode()"]
    pub fn clingo_propagate_init_get_check_mode(
        init: *const clingo_propagate_init_t,
    ) -> clingo_propagator_check_mode_t;
}
extern "C" {
    #[doc = "! Configure when to call the undo method of the propagator.\n!\n! @param[in] init the target\n! @param[in] mode when to call the propagator\n! @see @ref ::clingo_propagator::check()"]
    pub fn clingo_propagate_init_set_undo_mode(
        init: *mut clingo_propagate_init_t,
        mode: clingo_propagator_undo_mode_t,
    );
}
extern "C" {
    #[doc = "! Get the current undo mode of the propagator.\n!\n! @param[in] init the target\n! @see clingo_propagate_init_set_undo_mode()"]
    pub fn clingo_propagate_init_get_undo_mode(
        init: *const clingo_propagate_init_t,
    ) -> clingo_propagator_undo_mode_t;
}
extern "C" {
    #[doc = "! Get the top level assignment solver.\n!\n! @param[in] init the target\n! @return the assignment"]
    pub fn clingo_propagate_init_assignment(
        init: *const clingo_propagate_init_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Add a literal to the solver.\n!\n! To be able to use the variable in clauses during propagation or add watches to it, it has to be frozen.\n! Otherwise, it might be removed during preprocessing.\n!\n! @attention If varibales were added, subsequent calls to functions adding constraints or ::clingo_propagate_init_propagate() are expensive.\n! It is best to add varables in batches.\n!\n! @param[in] init the target\n! @param[in] freeze whether to freeze the literal\n! @param[out] result the added literal\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_literal(
        init: *mut clingo_propagate_init_t,
        freeze: bool,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given clause to the solver.\n!\n! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false.\n!\n! @param[in] init the target\n! @param[in] clause the clause to add\n! @param[in] size the size of the clause\n! @param[out] result result indicating whether the problem became unsatisfiable\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_clause(
        init: *mut clingo_propagate_init_t,
        clause: *const clingo_literal_t,
        size: usize,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given weight constraint to the solver.\n!\n! This function adds a constraint of form `literal <=> { lit=weight | (lit, weight) in literals } >= bound` to the solver.\n! Depending on the type the `<=>` connective can be either a left implication, right implication, or equivalence.\n!\n! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false.\n!\n! @param[in] init the target\n! @param[in] literal the literal of the constraint\n! @param[in] literals the weighted literals\n! @param[in] size the number of weighted literals\n! @param[in] bound the bound of the constraint\n! @param[in] type the type of the weight constraint\n! @param[in] compare_equal if true compare equal instead of less than equal\n! @param[out] result result indicating whether the problem became unsatisfiable\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_weight_constraint(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
        bound: clingo_weight_t,
        type_: clingo_weight_constraint_type_t,
        compare_equal: bool,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given literal to minimize to the solver.\n!\n! This corresponds to a weak constraint of form `:~ literal. [weight@priority]`.\n!\n! @param[in] init the target\n! @param[in] literal the literal to minimize\n! @param[in] weight the weight of the literal\n! @param[in] priority the priority of the literal\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_minimize(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        weight: clingo_weight_t,
        priority: clingo_weight_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagates consequences of the underlying problem excluding registered propagators.\n!\n! @note The function has no effect if SAT-preprocessing is enabled.\n! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false.\n!\n! @param[in] init the target\n! @param[out] result result indicating whether the problem became unsatisfiable\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_propagate(
        init: *mut clingo_propagate_init_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "!< clause is subject to the solvers deletion policy"]
pub const clingo_clause_type_e_clingo_clause_type_learnt: clingo_clause_type_e = 0;
#[doc = "!< clause is not subject to the solvers deletion policy"]
pub const clingo_clause_type_e_clingo_clause_type_static: clingo_clause_type_e = 1;
#[doc = "!< like ::clingo_clause_type_learnt but the clause is deleted after a solving step"]
pub const clingo_clause_type_e_clingo_clause_type_volatile: clingo_clause_type_e = 2;
#[doc = "!< like ::clingo_clause_type_static but the clause is deleted after a solving step"]
pub const clingo_clause_type_e_clingo_clause_type_volatile_static: clingo_clause_type_e = 3;
#[doc = "! Enumeration of clause types determining the lifetime of a clause.\n!\n! Clauses in the solver are either cleaned up based on a configurable deletion policy or at the end of a solving step.\n! The values of this enumeration determine if a clause is subject to one of the above deletion strategies."]
pub type clingo_clause_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_clause_type_e."]
pub type clingo_clause_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_control {
    _unused: [u8; 0],
}
#[doc = "! This object can be used to add clauses and propagate literals while solving."]
pub type clingo_propagate_control_t = clingo_propagate_control;
extern "C" {
    #[doc = "! Get the id of the underlying solver thread.\n!\n! Thread ids are consecutive numbers starting with zero.\n!\n! @param[in] control the target\n! @return the thread id"]
    pub fn clingo_propagate_control_thread_id(
        control: *const clingo_propagate_control_t,
    ) -> clingo_id_t;
}
extern "C" {
    #[doc = "! Get the assignment associated with the underlying solver.\n!\n! @param[in] control the target\n! @return the assignment"]
    pub fn clingo_propagate_control_assignment(
        control: *const clingo_propagate_control_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Adds a new volatile literal to the underlying solver thread.\n!\n! @attention The literal is only valid within the current solving step and solver thread.\n! All volatile literals and clauses involving a volatile literal are deleted after the current search.\n!\n! @param[in] control the target\n! @param[out] result the (positive) solver literal\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_logic if the assignment is conflicting"]
    pub fn clingo_propagate_control_add_literal(
        control: *mut clingo_propagate_control_t,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase.\n!\n! @note Unlike @ref clingo_propagate_init_add_watch() this does not add a watch to all solver threads but just the current one.\n!\n! @param[in] control the target\n! @param[in] literal the literal to watch\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_logic if the literal is invalid\n! @see clingo_propagate_control_remove_watch()"]
    pub fn clingo_propagate_control_add_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a literal is watched in the current solver thread.\n!\n! @param[in] control the target\n! @param[in] literal the literal to check\n!\n! @return whether the literal is watched"]
    pub fn clingo_propagate_control_has_watch(
        control: *const clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Removes the watch (if any) for the given solver literal.\n!\n! @note Similar to @ref clingo_propagate_init_add_watch() this just removes the watch in the current solver thread.\n!\n! @param[in] control the target\n! @param[in] literal the literal to remove"]
    pub fn clingo_propagate_control_remove_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    );
}
extern "C" {
    #[doc = "! Add the given clause to the solver.\n!\n! This method sets its result to false if the current propagation must be stopped for the solver to backtrack.\n!\n! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false.\n!\n! @param[in] control the target\n! @param[in] clause the clause to add\n! @param[in] size the size of the clause\n! @param[in] type the clause type determining its lifetime\n! @param[out] result result indicating whether propagation has to be stopped\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_add_clause(
        control: *mut clingo_propagate_control_t,
        clause: *const clingo_literal_t,
        size: usize,
        type_: clingo_clause_type_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagate implied literals (resulting from added clauses).\n!\n! This method sets its result to false if the current propagation must be stopped for the solver to backtrack.\n!\n! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false.\n!\n! @param[in] control the target\n! @param[out] result result indicating whether propagation has to be stopped\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_propagate(
        control: *mut clingo_propagate_control_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "! Typedef for @ref ::clingo_propagator::init()."]
pub type clingo_propagator_init_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_init_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::propagate()."]
pub type clingo_propagator_propagate_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::undo()."]
pub type clingo_propagator_undo_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "! Typedef for @ref ::clingo_propagator::check()."]
pub type clingo_propagator_check_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! @see Propagator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagator {
    #[doc = "! This function is called once before each solving step.\n! It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize the data structures used during propagation.\n!\n! @note This is the last point to access symbolic and theory atoms.\n! Once the search has started, they are no longer accessible.\n!\n! @param[in] init initizialization object\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_init_callback_t"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            init: *mut clingo_propagate_init_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Can be used to propagate solver literals given a @link clingo_assignment_t partial assignment@endlink.\n!\n! Called during propagation with a non-empty array of @link clingo_propagate_init_add_watch() watched solver literals@endlink\n! that have been assigned to true since the last call to either propagate, undo, (or the start of the search) - the change set.\n! Only watched solver literals are contained in the change set.\n! Each literal in the change set is true w.r.t. the current @link clingo_assignment_t assignment@endlink.\n! @ref clingo_propagate_control_add_clause() can be used to add clauses.\n! If a clause is unit resulting, it can be propagated using @ref clingo_propagate_control_propagate().\n! If the result of either of the two methods is false, the propagate function must return immediately.\n!\n! The following snippet shows how to use the methods to add clauses and propagate consequences within the callback.\n! The important point is to return true (true to indicate there was no error) if the result of either of the methods is false.\n! ~~~~~~~~~~~~~~~{.c}\n! bool result;\n! clingo_literal_t clause[] = { ... };\n!\n! // add a clause\n! if (!clingo_propagate_control_add_clause(control, clause, clingo_clause_type_learnt, &result) { return false; }\n! if (!result) { return true; }\n! // propagate its consequences\n! if (!clingo_propagate_control_propagate(control, &result) { return false; }\n! if (!result) { return true; }\n!\n! // add further clauses and propagate them\n! ...\n!\n! return true;\n! ~~~~~~~~~~~~~~~\n!\n! @note\n! This function can be called from different solving threads.\n! Each thread has its own assignment and id, which can be obtained using @ref clingo_propagate_control_thread_id().\n!\n! @param[in] control control object for the target solver\n! @param[in] changes the change set\n! @param[in] size the size of the change set\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_propagate_callback_t"]
    pub propagate: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Called whenever a solver undoes assignments to watched solver literals.\n!\n! This callback is meant to update assignment dependent state in the propagator.\n!\n! @note No clauses must be propagated in this callback and no errors should be set.\n!\n! @param[in] control control object for the target solver\n! @param[in] changes the change set\n! @param[in] size the size of the change set\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_undo_callback_t"]
    pub undo: ::std::option::Option<
        unsafe extern "C" fn(
            control: *const clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = "! This function is similar to @ref clingo_propagate_control_propagate() but is called without a change set on propagation fixpoints.\n!\n! When exactly this function is called, can be configured using the @ref clingo_propagate_init_set_check_mode() function.\n!\n! @note This function is called even if no watches have been added.\n!\n! @param[in] control control object for the target solver\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_check_callback_t"]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function allows a propagator to implement domain-specific heuristics.\n!\n! It is called whenever propagation reaches a fixed point and\n! should return a free solver literal that is to be assigned true.\n! In case multiple propagators are registered,\n! this function can return 0 to let a propagator registered later make a decision.\n! If all propagators return 0, then the fallback literal is\n!\n! @param[in] thread_id the solver's thread id\n! @param[in] assignment the assignment of the solver\n! @param[in] fallback the literal choosen by the solver's heuristic\n! @param[out] decision the literal to make true\n! @return whether the call was successful"]
    pub decide: ::std::option::Option<
        unsafe extern "C" fn(
            thread_id: clingo_id_t,
            assignment: *const clingo_assignment_t,
            fallback: clingo_literal_t,
            data: *mut ::std::os::raw::c_void,
            decision: *mut clingo_literal_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_propagator() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_propagator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_propagator>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_propagator))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_propagator>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_propagator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propagate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).undo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decide) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(decide)
        )
    );
}
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! @see Propagator"]
pub type clingo_propagator_t = clingo_propagator;
#[doc = "!< Comments."]
pub const clingo_comment_type_e_clingo_comment_type_line: clingo_comment_type_e = 0;
#[doc = "!< Block comments."]
pub const clingo_comment_type_e_clingo_comment_type_block: clingo_comment_type_e = 1;
#[doc = "! Enumeration of comment types."]
pub type clingo_comment_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_theory_sequence_type_e."]
pub type clingo_comment_type_t = ::std::os::raw::c_int;
#[doc = "!< Theory tuples \"(t1,...,tn)\"."]
pub const clingo_theory_sequence_type_e_clingo_theory_sequence_type_tuple:
    clingo_theory_sequence_type_e = 0;
#[doc = "!< Theory sets \"{t1,...,tn}\"."]
pub const clingo_theory_sequence_type_e_clingo_theory_sequence_type_set:
    clingo_theory_sequence_type_e = 1;
#[doc = "!< Theory lists \"[t1,...,tn]\"."]
pub const clingo_theory_sequence_type_e_clingo_theory_sequence_type_list:
    clingo_theory_sequence_type_e = 2;
#[doc = "! Enumeration of theory sequence types."]
pub type clingo_theory_sequence_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_theory_sequence_type_e."]
pub type clingo_theory_sequence_type_t = ::std::os::raw::c_int;
#[doc = "!< set the level of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_level: clingo_heuristic_type_e = 0;
#[doc = "!< configure which sign to chose for an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_sign: clingo_heuristic_type_e = 1;
#[doc = "!< modify VSIDS factor of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_factor: clingo_heuristic_type_e = 2;
#[doc = "!< modify the initial VSIDS score of an atom"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_init: clingo_heuristic_type_e = 3;
#[doc = "!< set the level of an atom and choose a positive sign"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_true: clingo_heuristic_type_e = 4;
#[doc = "!< set the level of an atom and choose a negative sign"]
pub const clingo_heuristic_type_e_clingo_heuristic_type_false: clingo_heuristic_type_e = 5;
#[doc = "! Enumeration of different heuristic modifiers.\n! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_heuristic_type_e.\n! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_t = ::std::os::raw::c_int;
#[doc = "!< allow an external to be assigned freely"]
pub const clingo_external_type_e_clingo_external_type_free: clingo_external_type_e = 0;
#[doc = "!< assign an external to true"]
pub const clingo_external_type_e_clingo_external_type_true: clingo_external_type_e = 1;
#[doc = "!< assign an external to false"]
pub const clingo_external_type_e_clingo_external_type_false: clingo_external_type_e = 2;
#[doc = "!< no longer treat an atom as external"]
pub const clingo_external_type_e_clingo_external_type_release: clingo_external_type_e = 3;
#[doc = "! Enumeration of different external statements.\n! @ingroup ProgramInspection"]
pub type clingo_external_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_external_type_e.\n! @ingroup ProgramInspection"]
pub type clingo_external_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_backend {
    _unused: [u8; 0],
}
#[doc = "! Handle to the backend to add directives in aspif format."]
pub type clingo_backend_t = clingo_backend;
extern "C" {
    #[doc = "! Prepare the backend for usage.\n!\n! @param[in] backend the target backend\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime"]
    pub fn clingo_backend_begin(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Finalize the backend after using it.\n!\n! @param[in] backend the target backend\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime"]
    pub fn clingo_backend_end(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Add a rule to the program.\n!\n! @param[in] backend the target backend\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] body the body literals\n! @param[in] body_size the number of literals in the body\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        body: *const clingo_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a weight rule to the program.\n!\n! @attention All weights and the lower bound must be positive.\n! @param[in] backend the target backend\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] lower_bound the lower bound of the weight rule\n! @param[in] body the weighted body literals\n! @param[in] body_size the number of weighted literals in the body\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_weight_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        lower_bound: clingo_weight_t,
        body: *const clingo_weighted_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a minimize constraint (or weak constraint) to the program.\n!\n! @param[in] backend the target backend\n! @param[in] priority the priority of the constraint\n! @param[in] literals the weighted literals whose sum to minimize\n! @param[in] size the number of weighted literals\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_minimize(
        backend: *mut clingo_backend_t,
        priority: clingo_weight_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a projection directive.\n!\n! @param[in] backend the target backend\n! @param[in] atoms the atoms to project on\n! @param[in] size the number of atoms\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_project(
        backend: *mut clingo_backend_t,
        atoms: *const clingo_atom_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an external statement.\n!\n! @param[in] backend the target backend\n! @param[in] atom the external atom\n! @param[in] type the type of the external statement\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_external(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_external_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an assumption directive.\n!\n! @param[in] backend the target backend\n! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)\n! @param[in] size the number of atoms\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_assume(
        backend: *mut clingo_backend_t,
        literals: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an heuristic directive.\n!\n! @param[in] backend the target backend\n! @param[in] atom the target atom\n! @param[in] type the type of the heuristic modification\n! @param[in] bias the heuristic bias\n! @param[in] priority the heuristic priority\n! @param[in] condition the condition under which to apply the heuristic modification\n! @param[in] size the number of atoms in the condition\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_heuristic(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_heuristic_type_t,
        bias: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_uint,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an edge directive.\n!\n! @param[in] backend the target backend\n! @param[in] node_u the start vertex of the edge\n! @param[in] node_v the end vertex of the edge\n! @param[in] condition the condition under which the edge is part of the graph\n! @param[in] size the number of atoms in the condition\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_acyc_edge(
        backend: *mut clingo_backend_t,
        node_u: ::std::os::raw::c_int,
        node_v: ::std::os::raw::c_int,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a fresh atom to be used in aspif directives.\n!\n! @param[in] backend the target backend\n! @param[in] symbol optional symbol to associate the atom with\n! @param[out] atom the resulting atom\n! @return whether the call was successful"]
    pub fn clingo_backend_add_atom(
        backend: *mut clingo_backend_t,
        symbol: *mut clingo_symbol_t,
        atom: *mut clingo_atom_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a numeric theory term.\n!\n! @param[in] backend the target backend\n! @param[in] number the value of the term\n! @param[out] term_id the resulting term id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_term_number(
        backend: *mut clingo_backend_t,
        number: ::std::os::raw::c_int,
        term_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory term representing a string.\n!\n! @param[in] backend the target backend\n! @param[in] string the value of the term\n! @param[out] term_id the resulting term id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_term_string(
        backend: *mut clingo_backend_t,
        string: *const ::std::os::raw::c_char,
        term_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory term representing a sequence of theory terms.\n!\n! @param[in] backend the target backend\n! @param[in] type the type of the sequence\n! @param[in] arguments the term ids of the terms in the sequence\n! @param[in] size the number of elements of the sequence\n! @param[out] term_id the resulting term id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_term_sequence(
        backend: *mut clingo_backend_t,
        type_: clingo_theory_sequence_type_t,
        arguments: *const clingo_id_t,
        size: usize,
        term_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory term representing a function.\n!\n! @param[in] backend the target backend\n! @param[in] name the name of the function\n! @param[in] arguments an array of term ids for the theory terms in the arguments\n! @param[in] size the number of arguments\n! @param[out] term_id the resulting term id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_term_function(
        backend: *mut clingo_backend_t,
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_id_t,
        size: usize,
        term_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Convert the given symbol into a theory term.\n!\n! @param[in] backend the target backend\n! @param[in] symbol the symbol to convert\n! @param[out] term_id the resulting term id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_term_symbol(
        backend: *mut clingo_backend_t,
        symbol: clingo_symbol_t,
        term_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory atom element.\n!\n! @param[in] backend the target backend\n! @param[in] tuple the array of term ids represeting the tuple\n! @param[in] tuple_size the size of the tuple\n! @param[in] condition an array of program literals represeting the condition\n! @param[in] condition_size the size of the condition\n! @param[out] element_id the resulting element id\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_element(
        backend: *mut clingo_backend_t,
        tuple: *const clingo_id_t,
        tuple_size: usize,
        condition: *const clingo_literal_t,
        condition_size: usize,
        element_id: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory atom without a guard.\n!\n! @param[in] backend the target backend\n! @param[in] atom_id_or_zero a program atom or zero for theory directives\n! @param[in] term_id the term id of the term associated with the theory atom\n! @param[in] elements an array of element ids for the theory atoms's elements\n! @param[in] size the number of elements\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_atom(
        backend: *mut clingo_backend_t,
        atom_id_or_zero: clingo_atom_t,
        term_id: clingo_id_t,
        elements: *const clingo_id_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a theory atom with a guard.\n!\n! @param[in] backend the target backend\n! @param[in] atom_id_or_zero a program atom or zero for theory directives\n! @param[in] term_id the term id of the term associated with the theory atom\n! @param[in] elements an array of element ids for the theory atoms's elements\n! @param[in] size the number of elements\n! @param[in] operator_name the string representation of a theory operator\n! @param[in] right_hand_side_id the term id of the right hand side term\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_theory_atom_with_guard(
        backend: *mut clingo_backend_t,
        atom_id_or_zero: clingo_atom_t,
        term_id: clingo_id_t,
        elements: *const clingo_id_t,
        size: usize,
        operator_name: *const ::std::os::raw::c_char,
        right_hand_side_id: clingo_id_t,
    ) -> bool;
}
#[doc = "!< the entry is a (string) value"]
pub const clingo_configuration_type_e_clingo_configuration_type_value: clingo_configuration_type_e =
    1;
#[doc = "!< the entry is an array"]
pub const clingo_configuration_type_e_clingo_configuration_type_array: clingo_configuration_type_e =
    2;
#[doc = "!< the entry is a map"]
pub const clingo_configuration_type_e_clingo_configuration_type_map: clingo_configuration_type_e =
    4;
#[doc = "! Enumeration for entries of the configuration."]
pub type clingo_configuration_type_e = ::std::os::raw::c_uint;
#[doc = "! Bitset for values of type ::clingo_configuration_type_e."]
pub type clingo_configuration_type_bitset_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_configuration {
    _unused: [u8; 0],
}
#[doc = "! Handle for to the solver configuration."]
pub type clingo_configuration_t = clingo_configuration;
extern "C" {
    #[doc = "! Get the root key of the configuration.\n!\n! @param[in] configuration the target configuration\n! @param[out] key the root key\n! @return whether the call was successful"]
    pub fn clingo_configuration_root(
        configuration: *const clingo_configuration_t,
        key: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key.\n!\n! @note The type is bitset, an entry can have multiple (but at least one) type.\n!\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] type the resulting type\n! @return whether the call was successful"]
    pub fn clingo_configuration_type(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        type_: *mut clingo_configuration_type_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the description of an entry.\n!\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] description the description\n! @return whether the call was successful"]
    pub fn clingo_configuration_description(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        description: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting size\n! @return whether the call was successful"]
    pub fn clingo_configuration_array_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry.\n!\n! @note Some array entries, like fore example the solver configuration, can be accessed past there actual size to add subentries.\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] offset the offset in the array\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_configuration_array_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting number\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Query whether the map has a key.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @note Multiple levels can be looked up by concatenating keys with a period.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] name the name to lookup the subkey\n! @param[out] result whether the key is in the map\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_has_subkey(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] offset the offset of the name\n! @param[out] name the resulting name\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_subkey_name(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @note Multiple levels can be looked up by concatenating keys with a period.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] name the name to lookup the subkey\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a entry has a value.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] assigned whether the entry has a value\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_is_assigned(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        assigned: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string value of the given entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting size\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_get_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string value of the given entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @pre The given size must be larger or equal to size of the value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] value the resulting string value\n! @param[in] size the size of the given char array\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_get(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        value: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] value the value to set\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_set(
        configuration: *mut clingo_configuration_t,
        key: clingo_id_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = "!< the entry is invalid (has neither of the types below)"]
pub const clingo_statistics_type_e_clingo_statistics_type_empty: clingo_statistics_type_e = 0;
#[doc = "!< the entry is a (double) value"]
pub const clingo_statistics_type_e_clingo_statistics_type_value: clingo_statistics_type_e = 1;
#[doc = "!< the entry is an array"]
pub const clingo_statistics_type_e_clingo_statistics_type_array: clingo_statistics_type_e = 2;
#[doc = "!< the entry is a map"]
pub const clingo_statistics_type_e_clingo_statistics_type_map: clingo_statistics_type_e = 3;
#[doc = "! Enumeration for entries of the statistics."]
pub type clingo_statistics_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_statistics_type."]
pub type clingo_statistics_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_statistic {
    _unused: [u8; 0],
}
#[doc = "! Handle for the solver statistics."]
pub type clingo_statistics_t = clingo_statistic;
extern "C" {
    #[doc = "! Get the root key of the statistics.\n!\n! @param[in] statistics the target statistics\n! @param[out] key the root key\n! @return whether the call was successful"]
    pub fn clingo_statistics_root(statistics: *const clingo_statistics_t, key: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key.\n!\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[out] type the resulting type\n! @return whether the call was successful"]
    pub fn clingo_statistics_type(
        statistics: *const clingo_statistics_t,
        key: u64,
        type_: *mut clingo_statistics_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[out] size the resulting size\n! @return whether the call was successful"]
    pub fn clingo_statistics_array_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] offset the offset in the array\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_statistics_array_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Create the subkey at the end of an array entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] type the type of the new subkey\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_statistics_array_push(
        statistics: *mut clingo_statistics_t,
        key: u64,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[out] size the resulting number\n! @return whether the call was successful"]
    pub fn clingo_statistics_map_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Test if the given map contains a specific subkey.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] name name of the subkey\n! @param[out] result true if the map has a subkey with the given name\n! @return whether the call was successful"]
    pub fn clingo_statistics_map_has_subkey(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] offset the offset of the name\n! @param[out] name the resulting name\n! @return whether the call was successful"]
    pub fn clingo_statistics_map_subkey_name(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.\n! @note Multiple levels can be looked up by concatenating keys with a period.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] name the name to lookup the subkey\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_statistics_map_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a subkey with the given name.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[in] name the name of the new subkey\n! @param[in] type the type of the new subkey\n! @param[out] subkey the index of the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_statistics_map_add_subkey(
        statistics: *mut clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of the given entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[out] value the resulting value\n! @return whether the call was successful"]
    pub fn clingo_statistics_value_get(
        statistics: *const clingo_statistics_t,
        key: u64,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of the given entry.\n!\n! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value.\n! @param[in] statistics the target statistics\n! @param[in] key the key\n! @param[out] value the new value\n! @return whether the call was successful"]
    pub fn clingo_statistics_value_set(
        statistics: *mut clingo_statistics_t,
        key: u64,
        value: f64,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_control {
    _unused: [u8; 0],
}
#[doc = "! Object to add clauses during search."]
pub type clingo_solve_control_t = clingo_solve_control;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_model {
    _unused: [u8; 0],
}
#[doc = "! Object representing a model."]
pub type clingo_model_t = clingo_model;
#[doc = "!< The model represents a stable model."]
pub const clingo_model_type_e_clingo_model_type_stable_model: clingo_model_type_e = 0;
#[doc = "!< The model represents a set of brave consequences."]
pub const clingo_model_type_e_clingo_model_type_brave_consequences: clingo_model_type_e = 1;
#[doc = "!< The model represents a set of cautious consequences."]
pub const clingo_model_type_e_clingo_model_type_cautious_consequences: clingo_model_type_e = 2;
#[doc = "! Enumeration for the different model types."]
pub type clingo_model_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_model_type_e."]
pub type clingo_model_type_t = ::std::os::raw::c_int;
#[doc = "!< Select shown atoms and terms."]
pub const clingo_show_type_e_clingo_show_type_shown: clingo_show_type_e = 2;
#[doc = "!< Select all atoms."]
pub const clingo_show_type_e_clingo_show_type_atoms: clingo_show_type_e = 4;
#[doc = "!< Select all terms."]
pub const clingo_show_type_e_clingo_show_type_terms: clingo_show_type_e = 8;
#[doc = "!< Select symbols added by theory."]
pub const clingo_show_type_e_clingo_show_type_theory: clingo_show_type_e = 16;
#[doc = "!< Select everything."]
pub const clingo_show_type_e_clingo_show_type_all: clingo_show_type_e = 31;
#[doc = "!< Select false instead of true atoms (::clingo_show_type_atoms) or terms (::clingo_show_type_terms)."]
pub const clingo_show_type_e_clingo_show_type_complement: clingo_show_type_e = 32;
#[doc = "! Enumeration of bit flags to select symbols in models."]
pub type clingo_show_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_show_type_e."]
pub type clingo_show_type_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< The literal is not a consequence."]
pub const clingo_consequence_e_clingo_consequence_false: clingo_consequence_e = 0;
#[doc = "!< The literal is a consequence."]
pub const clingo_consequence_e_clingo_consequence_true: clingo_consequence_e = 1;
#[doc = "!< The literal might or might not be a consequence."]
pub const clingo_consequence_e_clingo_consequence_unknown: clingo_consequence_e = 2;
#[doc = "! Enumeration for the different consequence types."]
pub type clingo_consequence_e = ::std::os::raw::c_uint;
pub type clingo_consequence_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Get the type of the model.\n!\n! @param[in] model the target\n! @param[out] type the type of the model\n! @return whether the call was successful"]
    pub fn clingo_model_type(model: *const clingo_model_t, type_: *mut clingo_model_type_t)
        -> bool;
}
extern "C" {
    #[doc = "! Get the running number of the model.\n!\n! @param[in] model the target\n! @param[out] number the number of the model\n! @return whether the call was successful"]
    pub fn clingo_model_number(model: *const clingo_model_t, number: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the number of symbols of the selected types in the model.\n!\n! @param[in] model the target\n! @param[in] show which symbols to select\n! @param[out] size the number symbols\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_model_symbols_size(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbols of the selected types in the model.\n!\n! @note CSP assignments are represented using functions with name \"$\"\n! where the first argument is the name of the CSP variable and the second one its\n! value.\n!\n! @param[in] model the target\n! @param[in] show which symbols to select\n! @param[out] symbols the resulting symbols\n! @param[in] size the number of selected symbols\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_symbols_size()"]
    pub fn clingo_model_symbols(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        symbols: *mut clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Constant time lookup to test whether an atom is in a model.\n!\n! @param[in] model the target\n! @param[in] atom the atom to lookup\n! @param[out] contained whether the atom is contained\n! @return whether the call was successful"]
    pub fn clingo_model_contains(
        model: *const clingo_model_t,
        atom: clingo_symbol_t,
        contained: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a program literal is true in a model.\n!\n! @param[in] model the target\n! @param[in] literal the literal to lookup\n! @param[out] result whether the literal is true\n! @return whether the call was successful"]
    pub fn clingo_model_is_true(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the given literal is a consequence.\n!\n! While enumerating cautious or brave consequences, there is partial\n! information about which literals are consequences. The current state of a\n! literal can be requested using this function. If this function is used\n! during normal model enumeration, the function just returns whether a\n! literal is true of false in the current model.\n!\n! @param[in] model the target\n! @param[in] literal the literal to lookup\n! @param[out] result whether the literal is a consequence\n! @return whether the call was successful"]
    pub fn clingo_model_is_consequence(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut clingo_consequence_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of cost values of a model.\n!\n! @param[in] model the target\n! @param[out] size the number of costs\n! @return whether the call was successful"]
    pub fn clingo_model_cost_size(model: *const clingo_model_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the cost vector of a model.\n!\n! @param[in] model the target\n! @param[out] costs the resulting costs\n! @param[in] size the number of costs\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_cost_size()\n! @see clingo_model_optimality_proven()"]
    pub fn clingo_model_cost(model: *const clingo_model_t, costs: *mut i64, size: usize) -> bool;
}
extern "C" {
    #[doc = "! Get the priorities of the costs.\n!\n! The size of the array can be obtained with clingo_model_cost_size().\n!\n! @param[in] model the target\n! @param[out] priorities the resulting priorities\n! @param[in] size the number of priorities\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_cost_size()"]
    pub fn clingo_model_priority(
        model: *const clingo_model_t,
        priorities: *mut clingo_weight_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Whether the optimality of a model has been proven.\n!\n! @param[in] model the target\n! @param[out] proven whether the optimality has been proven\n! @return whether the call was successful\n!\n! @see clingo_model_cost()"]
    pub fn clingo_model_optimality_proven(model: *const clingo_model_t, proven: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the solver thread that found the model.\n!\n! @param[in] model the target\n! @param[out] id the resulting thread id\n! @return whether the call was successful"]
    pub fn clingo_model_thread_id(model: *const clingo_model_t, id: *mut clingo_id_t) -> bool;
}
extern "C" {
    #[doc = "! Add symbols to the model.\n!\n! These symbols will appear in clingo's output, which means that this\n! function is only meaningful if there is an underlying clingo application.\n! Only models passed to the ::clingo_solve_event_callback_t are extendable.\n!\n! @param[in] model the target\n! @param[in] symbols the symbols to add\n! @param[in] size the number of symbols to add\n! @return whether the call was successful"]
    pub fn clingo_model_extend(
        model: *mut clingo_model_t,
        symbols: *const clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the associated solve control object of a model.\n!\n! This object allows for adding clauses during model enumeration.\n! @param[in] model the target\n! @param[out] control the resulting solve control object\n! @return whether the call was successful"]
    pub fn clingo_model_context(
        model: *const clingo_model_t,
        control: *mut *mut clingo_solve_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms.\n!\n! @param[in] control the target\n! @param[out] atoms the resulting object\n! @return whether the call was successful"]
    pub fn clingo_solve_control_symbolic_atoms(
        control: *const clingo_solve_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a clause that applies to the current solving step during model\n! enumeration.\n!\n! @note The @ref Propagator module provides a more sophisticated\n! interface to add clauses - even on partial assignments.\n!\n! @param[in] control the target\n! @param[in] clause array of literals representing the clause\n! @param[in] size the size of the literal array\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if adding the clause fails"]
    pub fn clingo_solve_control_add_clause(
        control: *mut clingo_solve_control_t,
        clause: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
pub const clingo_solve_result_e_clingo_solve_result_satisfiable: clingo_solve_result_e = 1;
pub const clingo_solve_result_e_clingo_solve_result_unsatisfiable: clingo_solve_result_e = 2;
pub const clingo_solve_result_e_clingo_solve_result_exhausted: clingo_solve_result_e = 4;
pub const clingo_solve_result_e_clingo_solve_result_interrupted: clingo_solve_result_e = 8;
pub type clingo_solve_result_e = ::std::os::raw::c_uint;
pub type clingo_solve_result_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Enable non-blocking search."]
pub const clingo_solve_mode_e_clingo_solve_mode_async: clingo_solve_mode_e = 1;
#[doc = "!< Yield models in calls to clingo_solve_handle_model."]
pub const clingo_solve_mode_e_clingo_solve_mode_yield: clingo_solve_mode_e = 2;
#[doc = "! Enumeration of solve modes."]
pub type clingo_solve_mode_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_mode_e."]
pub type clingo_solve_mode_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Issued if a model is found."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_model: clingo_solve_event_type_e = 0;
#[doc = "!< Issued if an optimization problem is found unsatisfiable."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_unsat: clingo_solve_event_type_e = 1;
#[doc = "!< Issued when the statistics can be updated."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_statistics: clingo_solve_event_type_e =
    2;
#[doc = "!< Issued if the search has completed."]
pub const clingo_solve_event_type_e_clingo_solve_event_type_finish: clingo_solve_event_type_e = 3;
#[doc = "! Enumeration of solve events."]
pub type clingo_solve_event_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_event_type_e."]
pub type clingo_solve_event_type_t = ::std::os::raw::c_uint;
#[doc = "! Callback function called during search to notify when the search is finished or a model is ready.\n!\n! If a (non-recoverable) clingo API function fails in this callback, it must return false.\n! In case of errors not related to clingo, set error code ::clingo_error_unknown and return false to stop solving with an error.\n!\n! The event is either a pointer to a model, a pointer to an int64_t* and a size_t, a pointer to two statistics objects (per step and accumulated statistics), or a solve result.\n! @attention If the search is finished, the model is NULL.\n!\n! @param[in] event the current event.\n! @param[in] data user data of the callback\n! @param[out] goon can be set to false to stop solving\n! @return whether the call was successful\n!\n! @see clingo_control_solve()"]
pub type clingo_solve_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: clingo_solve_event_type_t,
        event: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        goon: *mut bool,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_handle {
    _unused: [u8; 0],
}
#[doc = "! Search handle to a solve call.\n!\n! @see clingo_control_solve()"]
pub type clingo_solve_handle_t = clingo_solve_handle;
extern "C" {
    #[doc = "! Get the next solve result.\n!\n! Blocks until the result is ready.\n! When yielding partial solve results can be obtained, i.e.,\n! when a model is ready, the result will be satisfiable but neither the search exhausted nor the optimality proven.\n!\n! @param[in] handle the target\n! @param[out] result the solve result\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_get(
        handle: *mut clingo_solve_handle_t,
        result: *mut clingo_solve_result_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Wait for the specified amount of time to check if the next result is ready.\n!\n! If the time is set to zero, this function can be used to poll if the search is still active.\n! If the time is negative, the function blocks until the search is finished.\n!\n! @param[in] handle the target\n! @param[in] timeout the maximum time to wait\n! @param[out] result whether the search has finished"]
    pub fn clingo_solve_handle_wait(
        handle: *mut clingo_solve_handle_t,
        timeout: f64,
        result: *mut bool,
    );
}
extern "C" {
    #[doc = "! Get the next model (or zero if there are no more models).\n!\n! @param[in] handle the target\n! @param[out] model the model (it is NULL if there are no more models)\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_model(
        handle: *mut clingo_solve_handle_t,
        model: *mut *const clingo_model_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! When a problem is unsatisfiable, get a subset of the assumptions that made the problem unsatisfiable.\n!\n! If the program is not unsatisfiable, core is set to NULL and size to zero.\n!\n! @param[in] handle the target\n! @param[out] core pointer where to store the core\n! @param[out] size size of the given array\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_solve_handle_core(
        handle: *mut clingo_solve_handle_t,
        core: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Discards the last model and starts the search for the next one.\n!\n! If the search has been started asynchronously, this function continues the search in the background.\n!\n! @note This function does not block.\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_resume(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stop the running search and block until done.\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_cancel(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stops the running search and releases the handle.\n!\n! Blocks until the search is stopped (as if an implicit cancel was called before the handle is released).\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_close(handle: *mut clingo_solve_handle_t) -> bool;
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver.\n!\n! @note This interface is closely modeled after the aspif format.\n! For more information please refer to the specification of the aspif format.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! If one of the callbacks in the struct fails, grounding is stopped.\n! If a non-recoverable clingo API call fails, a callback must return false.\n! Otherwise ::clingo_error_unknown should be set and false returned.\n!\n! @see clingo_control_register_observer()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ground_program_observer {
    #[doc = "! Called once in the beginning.\n!\n! If the incremental flag is true, there can be multiple calls to @ref clingo_control_solve().\n!\n! @param[in] incremental whether the program is incremental\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub init_program: ::std::option::Option<
        unsafe extern "C" fn(incremental: bool, data: *mut ::std::os::raw::c_void) -> bool,
    >,
    #[doc = "! Marks the beginning of a block of directives passed to the solver.\n!\n! @see @ref end_step\n!\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub begin_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Marks the end of a block of directives passed to the solver.\n!\n! This function is called before solving starts.\n!\n! @see @ref begin_step\n!\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub end_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Observe rules passed to the solver.\n!\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] body the body literals\n! @param[in] body_size the number of literals in the body\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            body: *const clingo_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe weight rules passed to the solver.\n!\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] lower_bound the lower bound of the weight rule\n! @param[in] body the weighted body literals\n! @param[in] body_size the number of weighted literals in the body\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub weight_rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            lower_bound: clingo_weight_t,
            body: *const clingo_weighted_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe minimize constraints (or weak constraints) passed to the solver.\n!\n! @param[in] priority the priority of the constraint\n! @param[in] literals the weighted literals whose sum to minimize\n! @param[in] size the number of weighted literals\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub minimize: ::std::option::Option<
        unsafe extern "C" fn(
            priority: clingo_weight_t,
            literals: *const clingo_weighted_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe projection directives passed to the solver.\n!\n! @param[in] atoms the atoms to project on\n! @param[in] size the number of atoms\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub project: ::std::option::Option<
        unsafe extern "C" fn(
            atoms: *const clingo_atom_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown atoms passed to the solver.\n! \\note Facts do not have an associated aspif atom.\n! The value of the atom is set to zero.\n!\n! @param[in] symbol the symbolic representation of the atom\n! @param[in] atom the aspif atom (0 for facts)\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub output_atom: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            atom: clingo_atom_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown terms passed to the solver.\n!\n! @param[in] symbol the symbolic representation of the term\n! @param[in] condition the literals of the condition\n! @param[in] size the size of the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub output_term: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe external statements passed to the solver.\n!\n! @param[in] atom the external atom\n! @param[in] type the type of the external statement\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub external: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_external_type_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe assumption directives passed to the solver.\n!\n! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)\n! @param[in] size the number of atoms\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub assume: ::std::option::Option<
        unsafe extern "C" fn(
            literals: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe heuristic directives passed to the solver.\n!\n! @param[in] atom the target atom\n! @param[in] type the type of the heuristic modification\n! @param[in] bias the heuristic bias\n! @param[in] priority the heuristic priority\n! @param[in] condition the condition under which to apply the heuristic modification\n! @param[in] size the number of atoms in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub heuristic: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_heuristic_type_t,
            bias: ::std::os::raw::c_int,
            priority: ::std::os::raw::c_uint,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe edge directives passed to the solver.\n!\n! @param[in] node_u the start vertex of the edge\n! @param[in] node_v the end vertex of the edge\n! @param[in] condition the condition under which the edge is part of the graph\n! @param[in] size the number of atoms in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub acyc_edge: ::std::option::Option<
        unsafe extern "C" fn(
            node_u: ::std::os::raw::c_int,
            node_v: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe numeric theory terms.\n!\n! @param[in] term_id the id of the term\n! @param[in] number the value of the term\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_number: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            number: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe string theory terms.\n!\n! @param[in] term_id the id of the term\n! @param[in] name the value of the term\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_string: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe compound theory terms.\n!\n! The name_id_or_type gives the type of the compound term:\n! - if it is -1, then it is a tuple\n! - if it is -2, then it is a set\n! - if it is -3, then it is a list\n! - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term)\n!\n! @param[in] term_id the id of the term\n! @param[in] name_id_or_type the name or type of the term\n! @param[in] arguments the arguments of the term\n! @param[in] size the number of arguments\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_compound: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name_id_or_type: ::std::os::raw::c_int,
            arguments: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory elements.\n!\n! @param element_id the id of the element\n! @param terms the term tuple of the element\n! @param terms_size the number of terms in the tuple\n! @param condition the condition of the elemnt\n! @param condition_size the number of literals in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_element: ::std::option::Option<
        unsafe extern "C" fn(
            element_id: clingo_id_t,
            terms: *const clingo_id_t,
            terms_size: usize,
            condition: *const clingo_literal_t,
            condition_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms without guard.\n!\n! @param[in] atom_id_or_zero the id of the atom or zero for directives\n! @param[in] term_id the term associated with the atom\n! @param[in] elements the elements of the atom\n! @param[in] size the number of elements\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_atom: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms with guard.\n!\n! @param[in] atom_id_or_zero the id of the atom or zero for directives\n! @param[in] term_id the term associated with the atom\n! @param[in] elements the elements of the atom\n! @param[in] size the number of elements\n! @param[in] operator_id the id of the operator (a string term)\n! @param[in] right_hand_side_id the id of the term on the right hand side of the atom\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_atom_with_guard: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            operator_id: clingo_id_t,
            right_hand_side_id: clingo_id_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_ground_program_observer() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_ground_program_observer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_ground_program_observer>(),
        152usize,
        concat!("Size of: ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ground_program_observer>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_program) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(init_program)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_step) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(begin_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(end_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight_rule) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(weight_rule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(minimize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).project) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_atom) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_atom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_term) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).external) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assume) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(assume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heuristic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acyc_edge) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(acyc_edge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_term_number) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_term_string) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_term_compound) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_compound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_element) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_atom) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theory_atom_with_guard) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom_with_guard)
        )
    );
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver.\n!\n! @note This interface is closely modeled after the aspif format.\n! For more information please refer to the specification of the aspif format.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! If one of the callbacks in the struct fails, grounding is stopped.\n! If a non-recoverable clingo API call fails, a callback must return false.\n! Otherwise ::clingo_error_unknown should be set and false returned.\n!\n! @see clingo_control_register_observer()"]
pub type clingo_ground_program_observer_t = clingo_ground_program_observer;
#[doc = "! Struct used to specify the program parts that have to be grounded.\n!\n! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground.\n! Program parts are mainly interesting for incremental grounding and multi-shot solving.\n! For single-shot solving, program parts are not needed.\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @see clingo_control_ground()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_part {
    #[doc = "!< name of the program part"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< array of parameters"]
    pub params: *const clingo_symbol_t,
    #[doc = "!< number of parameters"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_part() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_part> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_part>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_part))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_part>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_part))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct used to specify the program parts that have to be grounded.\n!\n! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground.\n! Program parts are mainly interesting for incremental grounding and multi-shot solving.\n! For single-shot solving, program parts are not needed.\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @see clingo_control_ground()"]
pub type clingo_part_t = clingo_part;
#[doc = "! Callback function to implement external functions.\n!\n! If an external function of form <tt>\\@name(parameters)</tt> occurs in a logic program,\n! then this function is called with its location, name, parameters, and a callback to inject symbols as arguments.\n! The callback can be called multiple times; all symbols passed are injected.\n!\n! If a (non-recoverable) clingo API function fails in this callback, for example, the symbol callback, the callback must return false.\n! In case of errors not related to clingo, this function can set error ::clingo_error_unknown and return false to stop grounding with an error.\n!\n! @param[in] location location from which the external function was called\n! @param[in] name name of the called external function\n! @param[in] arguments arguments of the called external function\n! @param[in] arguments_size number of arguments\n! @param[in] data user data of the callback\n! @param[in] symbol_callback function to inject symbols\n! @param[in] symbol_callback_data user data for the symbol callback\n!            (must be passed untouched)\n! @return whether the call was successful\n! @see clingo_control_ground()\n!\n! The following example implements the external function <tt>\\@f()</tt> returning 42.\n! ~~~~~~~~~~~~~~~{.c}\n! bool\n! ground_callback(clingo_location_t const *location,\n!                 char const *name,\n!                 clingo_symbol_t const *arguments,\n!                 size_t arguments_size,\n!                 void *data,\n!                 clingo_symbol_callback_t symbol_callback,\n!                 void *symbol_callback_data) {\n!   if (strcmp(name, \"f\") == 0 && arguments_size == 0) {\n!     clingo_symbol_t sym;\n!     clingo_symbol_create_number(42, &sym);\n!     return symbol_callback(&sym, 1, symbol_callback_data);\n!   }\n!   clingo_set_error(clingo_error_runtime, \"function not found\");\n!   return false;\n! }\n! ~~~~~~~~~~~~~~~"]
pub type clingo_ground_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const clingo_location_t,
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        data: *mut ::std::os::raw::c_void,
        symbol_callback: clingo_symbol_callback_t,
        symbol_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_control {
    _unused: [u8; 0],
}
#[doc = "! Control object holding grounding and solving state."]
pub type clingo_control_t = clingo_control;
extern "C" {
    #[doc = "! Create a new control object.\n!\n! A control object has to be freed using clingo_control_free().\n!\n! @note Only gringo options (without <code>\\-\\-output</code>) and clasp's options are supported as arguments,\n! except basic options such as <code>\\-\\-help</code>.\n! Furthermore, a control object is blocked while a search call is active;\n! you must not call any member function during search.\n!\n! If the logger is NULL, messages are printed to stderr.\n!\n! @param[in] arguments C string array of command line arguments\n! @param[in] arguments_size size of the arguments array\n! @param[in] logger callback functions for warnings and info messages\n! @param[in] logger_data user data for the logger callback\n! @param[in] message_limit maximum number of times the logger callback is called\n! @param[out] control resulting control object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if argument parsing fails"]
    pub fn clingo_control_new(
        arguments: *const *const ::std::os::raw::c_char,
        arguments_size: usize,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        control: *mut *mut clingo_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Free a control object created with clingo_control_new().\n! @param[in] control the target"]
    pub fn clingo_control_free(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Extend the logic program with a program in a file.\n!\n! @param[in] control the target\n! @param[in] file path to the file\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing or checking fails"]
    pub fn clingo_control_load(
        control: *mut clingo_control_t,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Extend the logic program with the given non-ground logic program in string form.\n!\n! This function puts the given program into a block of form: <tt>\\#program name(parameters).</tt>\n!\n! After extending the logic program, the corresponding program parts are typically grounded with ::clingo_control_ground.\n!\n! @param[in] control the target\n! @param[in] name name of the program block\n! @param[in] parameters string array of parameters of the program block\n! @param[in] parameters_size number of parameters\n! @param[in] program string representation of the program\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_control_add(
        control: *mut clingo_control_t,
        name: *const ::std::os::raw::c_char,
        parameters: *const *const ::std::os::raw::c_char,
        parameters_size: usize,
        program: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Ground the selected @link ::clingo_part parts @endlink of the current (non-ground) logic program.\n!\n! After grounding, logic programs can be solved with ::clingo_control_solve().\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @param[in] control the target\n! @param[in] parts array of parts to ground\n! @param[in] parts_size size of the parts array\n! @param[in] ground_callback callback to implement external functions\n! @param[in] ground_callback_data user data for ground_callback\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - error code of ground callback\n!\n! @see clingo_part"]
    pub fn clingo_control_ground(
        control: *mut clingo_control_t,
        parts: *const clingo_part_t,
        parts_size: usize,
        ground_callback: clingo_ground_callback_t,
        ground_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Solve the currently @link ::clingo_control_ground grounded @endlink logic program enumerating its models.\n!\n! See the @ref SolveHandle module for more information.\n!\n! @param[in] control the target\n! @param[in] mode configures the search mode\n! @param[in] assumptions array of assumptions to solve under\n! @param[in] assumptions_size number of assumptions\n! @param[in] notify the event handler to register\n! @param[in] data the user data for the event handler\n! @param[out] handle handle to the current search to enumerate models\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving could not be started"]
    pub fn clingo_control_solve(
        control: *mut clingo_control_t,
        mode: clingo_solve_mode_bitset_t,
        assumptions: *const clingo_literal_t,
        assumptions_size: usize,
        notify: clingo_solve_event_callback_t,
        data: *mut ::std::os::raw::c_void,
        handle: *mut *mut clingo_solve_handle_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! @param[in] control the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n!\n! @see clingo_control_get_enable_cleanup()\n! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Assign a truth value to an external atom.\n!\n! If a negative literal is passed, the corresponding atom is assigned the\n! inverted truth value.\n!\n! If the atom does not exist or is not external, this is a noop.\n!\n! @param[in] control the target\n! @param[in] literal literal to assign\n! @param[in] value the truth value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_assign_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
        value: clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Release an external atom.\n!\n! If a negative literal is passed, the corresponding atom is released.\n!\n! After this call, an external atom is no longer external and subject to\n! program simplifications.  If the atom does not exist or is not external,\n! this is a noop.\n!\n! @param[in] control the target\n! @param[in] literal literal to release\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_release_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a custom propagator with the control object.\n!\n! If the sequential flag is set to true, the propagator is called\n! sequentially when solving with multiple threads.\n!\n! See the @ref Propagator module for more information.\n!\n! @param[in] control the target\n! @param[in] propagator the propagator\n! @param[in] data user data passed to the propagator functions\n! @param[in] sequential whether the propagator should be called sequentially\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_register_propagator(
        control: *mut clingo_control_t,
        propagator: *const clingo_propagator_t,
        data: *mut ::std::os::raw::c_void,
        sequential: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the solver has determined that the internal program representation is conflicting.\n!\n! If this function returns true, solve calls will return immediately with an unsatisfiable solve result.\n! Note that conflicts first have to be detected, e.g. -\n! initial unit propagation results in an empty clause,\n! or later if an empty clause is resolved during solving.\n! Hence, the function might return false even if the problem is unsatisfiable.\n!\n! @param[in] control the target\n! @return whether the program representation is conflicting"]
    pub fn clingo_control_is_conflicting(control: *const clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Get a statistics object to inspect solver statistics.\n!\n! Statistics are updated after a solve call.\n!\n! See the @ref Statistics module for more information.\n!\n! @attention\n! The level of detail of the statistics depends on the stats option\n! (which can be set using @ref Configuration module or passed as an option when @link clingo_control_new creating the control object@endlink).\n! The default level zero only provides basic statistics,\n! level one provides extended and accumulated statistics,\n! and level two provides per-thread statistics.\n! Furthermore, the statistics object is best accessed right after solving.\n! Otherwise, not all of its entries have valid values.\n!\n! @param[in] control the target\n! @param[out] statistics the statistics object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_statistics(
        control: *const clingo_control_t,
        statistics: *mut *const clingo_statistics_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Interrupt the active solve call (or the following solve call right at the beginning).\n!\n! @param[in] control the target"]
    pub fn clingo_control_interrupt(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Get low-level access to clasp.\n!\n! @attention\n! This function is intended for experimental use only and not part of the stable API.\n!\n! This function may return a <code>nullptr</code>.\n! Otherwise, the returned pointer can be casted to a ClaspFacade pointer.\n!\n! @param[in] control the target\n! @param[out] clasp pointer to the ClaspFacade object (may be <code>nullptr</code>)\n! @return whether the call was successful"]
    pub fn clingo_control_clasp_facade(
        control: *mut clingo_control_t,
        clasp: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a configuration object to change the solver configuration.\n!\n! See the @ref Configuration module for more information.\n!\n! @param[in] control the target\n! @param[out] configuration the configuration object\n! @return whether the call was successful"]
    pub fn clingo_control_configuration(
        control: *mut clingo_control_t,
        configuration: *mut *mut clingo_configuration_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Configure how learnt constraints are handled during enumeration.\n!\n! If the enumeration assumption is enabled, then all information learnt from\n! the solver's various enumeration modes is removed after a solve call. This\n! includes enumeration of cautious or brave consequences, enumeration of\n! answer sets with or without projection, or finding optimal models, as well\n! as clauses added with clingo_solve_control_add_clause().\n!\n! @attention For practical purposes, this option is only interesting for single-shot solving\n! or before the last solve call to squeeze out a tiny bit of performance.\n! Initially, the enumeration assumption is enabled.\n!\n! @param[in] control the target\n! @param[in] enable whether to enable the assumption\n! @return whether the call was successful"]
    pub fn clingo_control_set_enable_enumeration_assumption(
        control: *mut clingo_control_t,
        enable: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether the enumeration assumption is enabled.\n!\n! See ::clingo_control_set_enable_enumeration_assumption().\n! @param[in] control the target\n! @return whether using the enumeration assumption is enabled"]
    pub fn clingo_control_get_enable_enumeration_assumption(control: *mut clingo_control_t)
        -> bool;
}
extern "C" {
    #[doc = "! Enable automatic cleanup after solving.\n!\n! @note Cleanup is enabled by default.\n!\n! @param[in] control the target\n! @param[in] enable whether to enable cleanups\n! @return whether the call was successful\n!\n! @see clingo_control_cleanup()\n! @see clingo_control_get_enable_cleanup()"]
    pub fn clingo_control_set_enable_cleanup(control: *mut clingo_control_t, enable: bool) -> bool;
}
extern "C" {
    #[doc = "! Check whether automatic cleanup is enabled.\n!\n! See ::clingo_control_set_enable_cleanup().\n!\n! @param[in] control the target\n!\n! @see clingo_control_cleanup()\n! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_get_enable_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Return the symbol for a constant definition of form: <tt>\\#const name = symbol</tt>.\n!\n! @param[in] control the target\n! @param[in] name the name of the constant\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful"]
    pub fn clingo_control_get_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if there is a constant definition for the given constant.\n!\n! @param[in] control the target\n! @param[in] name the name of the constant\n! @param[out] exists whether a matching constant definition exists\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if constant definition does not exist\n!\n! @see clingo_control_get_const()"]
    pub fn clingo_control_has_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        exists: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect symbolic atoms (the relevant Herbrand base) used\n! for grounding.\n!\n! See the @ref SymbolicAtoms module for more information.\n!\n! @param[in] control the target\n! @param[out] atoms the symbolic atoms object\n! @return whether the call was successful"]
    pub fn clingo_control_symbolic_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect theory atoms that occur in the grounding.\n!\n! See the @ref TheoryAtoms module for more information.\n!\n! @param[in] control the target\n! @param[out] atoms the theory atoms object\n! @return whether the call was successful"]
    pub fn clingo_control_theory_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a program observer with the control object.\n!\n! @param[in] control the target\n! @param[in] observer the observer to register\n! @param[in] replace just pass the grounding to the observer but not the solver\n! @param[in] data user data passed to the observer functions\n! @return whether the call was successful"]
    pub fn clingo_control_register_observer(
        control: *mut clingo_control_t,
        observer: *const clingo_ground_program_observer_t,
        replace: bool,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to add ground directives to the program.\n!\n! See the @ref ProgramBuilder module for more information.\n!\n! @param[in] control the target\n! @param[out] backend the backend object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_backend(
        control: *mut clingo_control_t,
        backend: *mut *mut clingo_backend_t,
    ) -> bool;
}
#[doc = "!< Theory tuples \"(t1,...,tn)\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_tuple:
    clingo_ast_theory_sequence_type_e = 0;
#[doc = "!< Theory lists \"[t1,...,tn]\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_list:
    clingo_ast_theory_sequence_type_e = 2;
#[doc = "!< Theory sets \"{t1,...,tn}\"."]
pub const clingo_ast_theory_sequence_type_e_clingo_ast_theory_sequence_type_set:
    clingo_ast_theory_sequence_type_e = 1;
#[doc = "! Enumeration of theory sequence types.\n!\n! Same as clingo_theory_sequence_type_e but kept for backward compatibility."]
pub type clingo_ast_theory_sequence_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_sequence_type_e."]
pub type clingo_ast_theory_sequence_type_t = ::std::os::raw::c_int;
#[doc = "!< Operator \">\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_greater_than:
    clingo_ast_comparison_operator_e = 0;
#[doc = "!< Operator \"<\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_less_than:
    clingo_ast_comparison_operator_e = 1;
#[doc = "!< Operator \"<=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_less_equal:
    clingo_ast_comparison_operator_e = 2;
#[doc = "!< Operator \">=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_greater_equal:
    clingo_ast_comparison_operator_e = 3;
#[doc = "!< Operator \"!=\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_not_equal:
    clingo_ast_comparison_operator_e = 4;
#[doc = "!< Operator \"==\"."]
pub const clingo_ast_comparison_operator_e_clingo_ast_comparison_operator_equal:
    clingo_ast_comparison_operator_e = 5;
#[doc = "! Enumeration of comparison relations."]
pub type clingo_ast_comparison_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_comparison_operator_e."]
pub type clingo_ast_comparison_operator_t = ::std::os::raw::c_int;
#[doc = "!< For positive literals."]
pub const clingo_ast_sign_e_clingo_ast_sign_no_sign: clingo_ast_sign_e = 0;
#[doc = "!< For negative literals (prefix \"not\")."]
pub const clingo_ast_sign_e_clingo_ast_sign_negation: clingo_ast_sign_e = 1;
#[doc = "!< For double negated literals (prefix \"not not\")."]
pub const clingo_ast_sign_e_clingo_ast_sign_double_negation: clingo_ast_sign_e = 2;
#[doc = "! Enumeration of signs."]
pub type clingo_ast_sign_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_sign_t."]
pub type clingo_ast_sign_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_minus: clingo_ast_unary_operator_e =
    0;
#[doc = "!< Operator \"~\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_negation:
    clingo_ast_unary_operator_e = 1;
#[doc = "!< Operator \"|.|\"."]
pub const clingo_ast_unary_operator_e_clingo_ast_unary_operator_absolute:
    clingo_ast_unary_operator_e = 2;
#[doc = "! Enumeration of unary operators."]
pub type clingo_ast_unary_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_unary_operator_e."]
pub type clingo_ast_unary_operator_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"^\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_xor:
    clingo_ast_binary_operator_e = 0;
#[doc = "!< Operator \"?\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_or: clingo_ast_binary_operator_e =
    1;
#[doc = "!< Operator \"&\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_and:
    clingo_ast_binary_operator_e = 2;
#[doc = "!< Operator \"+\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_plus:
    clingo_ast_binary_operator_e = 3;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_minus:
    clingo_ast_binary_operator_e = 4;
#[doc = "!< Operator \"*\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_multiplication:
    clingo_ast_binary_operator_e = 5;
#[doc = "!< Operator \"/\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_division:
    clingo_ast_binary_operator_e = 6;
#[doc = "!< Operator \"\\\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_modulo:
    clingo_ast_binary_operator_e = 7;
#[doc = "!< Operator \"**\"."]
pub const clingo_ast_binary_operator_e_clingo_ast_binary_operator_power:
    clingo_ast_binary_operator_e = 8;
#[doc = "! Enumeration of binary operators."]
pub type clingo_ast_binary_operator_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_binary_operator_e."]
pub type clingo_ast_binary_operator_t = ::std::os::raw::c_int;
#[doc = "!< Operator \"^\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_count:
    clingo_ast_aggregate_function_e = 0;
#[doc = "!< Operator \"?\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_sum:
    clingo_ast_aggregate_function_e = 1;
#[doc = "!< Operator \"&\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_sump:
    clingo_ast_aggregate_function_e = 2;
#[doc = "!< Operator \"+\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_min:
    clingo_ast_aggregate_function_e = 3;
#[doc = "!< Operator \"-\"."]
pub const clingo_ast_aggregate_function_e_clingo_ast_aggregate_function_max:
    clingo_ast_aggregate_function_e = 4;
#[doc = "! Enumeration of aggregate functions."]
pub type clingo_ast_aggregate_function_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_aggregate_function_e."]
pub type clingo_ast_aggregate_function_t = ::std::os::raw::c_int;
#[doc = "!< An unary theory operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_unary:
    clingo_ast_theory_operator_type_e = 0;
#[doc = "!< A left associative binary operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_binary_left:
    clingo_ast_theory_operator_type_e = 1;
#[doc = "!< A right associative binary operator."]
pub const clingo_ast_theory_operator_type_e_clingo_ast_theory_operator_type_binary_right:
    clingo_ast_theory_operator_type_e = 2;
#[doc = "! Enumeration of theory operators."]
pub type clingo_ast_theory_operator_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_operator_type_e."]
pub type clingo_ast_theory_operator_type_t = ::std::os::raw::c_int;
#[doc = "!< For theory atoms that can appear in the head."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_head:
    clingo_ast_theory_atom_definition_type_e = 0;
#[doc = "!< For theory atoms that can appear in the body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_body:
    clingo_ast_theory_atom_definition_type_e = 1;
#[doc = "!< For theory atoms that can appear in both head and body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_any:
    clingo_ast_theory_atom_definition_type_e = 2;
#[doc = "!< For theory atoms that must not have a body."]
pub const clingo_ast_theory_atom_definition_type_e_clingo_ast_theory_atom_definition_type_directive : clingo_ast_theory_atom_definition_type_e = 3 ;
#[doc = "! Enumeration of the theory atom types."]
pub type clingo_ast_theory_atom_definition_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_theory_atom_definition_type_e."]
pub type clingo_ast_theory_atom_definition_type_t = ::std::os::raw::c_int;
pub const clingo_ast_type_e_clingo_ast_type_id: clingo_ast_type_e = 0;
pub const clingo_ast_type_e_clingo_ast_type_variable: clingo_ast_type_e = 1;
pub const clingo_ast_type_e_clingo_ast_type_symbolic_term: clingo_ast_type_e = 2;
pub const clingo_ast_type_e_clingo_ast_type_unary_operation: clingo_ast_type_e = 3;
pub const clingo_ast_type_e_clingo_ast_type_binary_operation: clingo_ast_type_e = 4;
pub const clingo_ast_type_e_clingo_ast_type_interval: clingo_ast_type_e = 5;
pub const clingo_ast_type_e_clingo_ast_type_function: clingo_ast_type_e = 6;
pub const clingo_ast_type_e_clingo_ast_type_pool: clingo_ast_type_e = 7;
pub const clingo_ast_type_e_clingo_ast_type_boolean_constant: clingo_ast_type_e = 8;
pub const clingo_ast_type_e_clingo_ast_type_symbolic_atom: clingo_ast_type_e = 9;
pub const clingo_ast_type_e_clingo_ast_type_comparison: clingo_ast_type_e = 10;
pub const clingo_ast_type_e_clingo_ast_type_guard: clingo_ast_type_e = 11;
pub const clingo_ast_type_e_clingo_ast_type_conditional_literal: clingo_ast_type_e = 12;
pub const clingo_ast_type_e_clingo_ast_type_aggregate: clingo_ast_type_e = 13;
pub const clingo_ast_type_e_clingo_ast_type_body_aggregate_element: clingo_ast_type_e = 14;
pub const clingo_ast_type_e_clingo_ast_type_body_aggregate: clingo_ast_type_e = 15;
pub const clingo_ast_type_e_clingo_ast_type_head_aggregate_element: clingo_ast_type_e = 16;
pub const clingo_ast_type_e_clingo_ast_type_head_aggregate: clingo_ast_type_e = 17;
pub const clingo_ast_type_e_clingo_ast_type_disjunction: clingo_ast_type_e = 18;
pub const clingo_ast_type_e_clingo_ast_type_theory_sequence: clingo_ast_type_e = 19;
pub const clingo_ast_type_e_clingo_ast_type_theory_function: clingo_ast_type_e = 20;
pub const clingo_ast_type_e_clingo_ast_type_theory_unparsed_term_element: clingo_ast_type_e = 21;
pub const clingo_ast_type_e_clingo_ast_type_theory_unparsed_term: clingo_ast_type_e = 22;
pub const clingo_ast_type_e_clingo_ast_type_theory_guard: clingo_ast_type_e = 23;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom_element: clingo_ast_type_e = 24;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom: clingo_ast_type_e = 25;
pub const clingo_ast_type_e_clingo_ast_type_literal: clingo_ast_type_e = 26;
pub const clingo_ast_type_e_clingo_ast_type_theory_operator_definition: clingo_ast_type_e = 27;
pub const clingo_ast_type_e_clingo_ast_type_theory_term_definition: clingo_ast_type_e = 28;
pub const clingo_ast_type_e_clingo_ast_type_theory_guard_definition: clingo_ast_type_e = 29;
pub const clingo_ast_type_e_clingo_ast_type_theory_atom_definition: clingo_ast_type_e = 30;
pub const clingo_ast_type_e_clingo_ast_type_rule: clingo_ast_type_e = 31;
pub const clingo_ast_type_e_clingo_ast_type_definition: clingo_ast_type_e = 32;
pub const clingo_ast_type_e_clingo_ast_type_show_signature: clingo_ast_type_e = 33;
pub const clingo_ast_type_e_clingo_ast_type_show_term: clingo_ast_type_e = 34;
pub const clingo_ast_type_e_clingo_ast_type_minimize: clingo_ast_type_e = 35;
pub const clingo_ast_type_e_clingo_ast_type_script: clingo_ast_type_e = 36;
pub const clingo_ast_type_e_clingo_ast_type_program: clingo_ast_type_e = 37;
pub const clingo_ast_type_e_clingo_ast_type_external: clingo_ast_type_e = 38;
pub const clingo_ast_type_e_clingo_ast_type_edge: clingo_ast_type_e = 39;
pub const clingo_ast_type_e_clingo_ast_type_heuristic: clingo_ast_type_e = 40;
pub const clingo_ast_type_e_clingo_ast_type_project_atom: clingo_ast_type_e = 41;
pub const clingo_ast_type_e_clingo_ast_type_project_signature: clingo_ast_type_e = 42;
pub const clingo_ast_type_e_clingo_ast_type_defined: clingo_ast_type_e = 43;
pub const clingo_ast_type_e_clingo_ast_type_theory_definition: clingo_ast_type_e = 44;
pub const clingo_ast_type_e_clingo_ast_type_comment: clingo_ast_type_e = 45;
#[doc = "! Enumeration of AST types."]
pub type clingo_ast_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_type_e."]
pub type clingo_ast_type_t = ::std::os::raw::c_int;
#[doc = "!< For an attribute of type \"int\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_number:
    clingo_ast_attribute_type_e = 0;
#[doc = "!< For an attribute of type \"clingo_ast_symbol_t\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_symbol:
    clingo_ast_attribute_type_e = 1;
#[doc = "!< For an attribute of type \"clingo_location_t\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_location:
    clingo_ast_attribute_type_e = 2;
#[doc = "!< For an attribute of type \"char const *\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_string:
    clingo_ast_attribute_type_e = 3;
#[doc = "!< For an attribute of type \"clingo_ast_t *\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_ast: clingo_ast_attribute_type_e =
    4;
#[doc = "!< For an attribute of type \"clingo_ast_t *\" that can be NULL."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_optional_ast:
    clingo_ast_attribute_type_e = 5;
#[doc = "!< For an attribute of type \"char const **\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_string_array:
    clingo_ast_attribute_type_e = 6;
#[doc = "!< For an attribute of type \"clingo_ast_t **\"."]
pub const clingo_ast_attribute_type_e_clingo_ast_attribute_type_ast_array:
    clingo_ast_attribute_type_e = 7;
#[doc = "! Enumeration of attributes types used by the AST."]
pub type clingo_ast_attribute_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_attribute_type."]
pub type clingo_ast_attribute_type_t = ::std::os::raw::c_int;
pub const clingo_ast_attribute_e_clingo_ast_attribute_argument: clingo_ast_attribute_e = 0;
pub const clingo_ast_attribute_e_clingo_ast_attribute_arguments: clingo_ast_attribute_e = 1;
pub const clingo_ast_attribute_e_clingo_ast_attribute_arity: clingo_ast_attribute_e = 2;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atom: clingo_ast_attribute_e = 3;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atoms: clingo_ast_attribute_e = 4;
pub const clingo_ast_attribute_e_clingo_ast_attribute_atom_type: clingo_ast_attribute_e = 5;
pub const clingo_ast_attribute_e_clingo_ast_attribute_bias: clingo_ast_attribute_e = 6;
pub const clingo_ast_attribute_e_clingo_ast_attribute_body: clingo_ast_attribute_e = 7;
pub const clingo_ast_attribute_e_clingo_ast_attribute_code: clingo_ast_attribute_e = 8;
pub const clingo_ast_attribute_e_clingo_ast_attribute_coefficient: clingo_ast_attribute_e = 9;
pub const clingo_ast_attribute_e_clingo_ast_attribute_comparison: clingo_ast_attribute_e = 10;
pub const clingo_ast_attribute_e_clingo_ast_attribute_condition: clingo_ast_attribute_e = 11;
pub const clingo_ast_attribute_e_clingo_ast_attribute_elements: clingo_ast_attribute_e = 12;
pub const clingo_ast_attribute_e_clingo_ast_attribute_external: clingo_ast_attribute_e = 13;
pub const clingo_ast_attribute_e_clingo_ast_attribute_external_type: clingo_ast_attribute_e = 14;
pub const clingo_ast_attribute_e_clingo_ast_attribute_function: clingo_ast_attribute_e = 15;
pub const clingo_ast_attribute_e_clingo_ast_attribute_guard: clingo_ast_attribute_e = 16;
pub const clingo_ast_attribute_e_clingo_ast_attribute_guards: clingo_ast_attribute_e = 17;
pub const clingo_ast_attribute_e_clingo_ast_attribute_head: clingo_ast_attribute_e = 18;
pub const clingo_ast_attribute_e_clingo_ast_attribute_is_default: clingo_ast_attribute_e = 19;
pub const clingo_ast_attribute_e_clingo_ast_attribute_left: clingo_ast_attribute_e = 20;
pub const clingo_ast_attribute_e_clingo_ast_attribute_left_guard: clingo_ast_attribute_e = 21;
pub const clingo_ast_attribute_e_clingo_ast_attribute_literal: clingo_ast_attribute_e = 22;
pub const clingo_ast_attribute_e_clingo_ast_attribute_location: clingo_ast_attribute_e = 23;
pub const clingo_ast_attribute_e_clingo_ast_attribute_modifier: clingo_ast_attribute_e = 24;
pub const clingo_ast_attribute_e_clingo_ast_attribute_name: clingo_ast_attribute_e = 25;
pub const clingo_ast_attribute_e_clingo_ast_attribute_node_u: clingo_ast_attribute_e = 26;
pub const clingo_ast_attribute_e_clingo_ast_attribute_node_v: clingo_ast_attribute_e = 27;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operator_name: clingo_ast_attribute_e = 28;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operator_type: clingo_ast_attribute_e = 29;
pub const clingo_ast_attribute_e_clingo_ast_attribute_operators: clingo_ast_attribute_e = 30;
pub const clingo_ast_attribute_e_clingo_ast_attribute_parameters: clingo_ast_attribute_e = 31;
pub const clingo_ast_attribute_e_clingo_ast_attribute_positive: clingo_ast_attribute_e = 32;
pub const clingo_ast_attribute_e_clingo_ast_attribute_priority: clingo_ast_attribute_e = 33;
pub const clingo_ast_attribute_e_clingo_ast_attribute_right: clingo_ast_attribute_e = 34;
pub const clingo_ast_attribute_e_clingo_ast_attribute_right_guard: clingo_ast_attribute_e = 35;
pub const clingo_ast_attribute_e_clingo_ast_attribute_sequence_type: clingo_ast_attribute_e = 36;
pub const clingo_ast_attribute_e_clingo_ast_attribute_sign: clingo_ast_attribute_e = 37;
pub const clingo_ast_attribute_e_clingo_ast_attribute_symbol: clingo_ast_attribute_e = 38;
pub const clingo_ast_attribute_e_clingo_ast_attribute_term: clingo_ast_attribute_e = 39;
pub const clingo_ast_attribute_e_clingo_ast_attribute_terms: clingo_ast_attribute_e = 40;
pub const clingo_ast_attribute_e_clingo_ast_attribute_value: clingo_ast_attribute_e = 41;
pub const clingo_ast_attribute_e_clingo_ast_attribute_variable: clingo_ast_attribute_e = 42;
pub const clingo_ast_attribute_e_clingo_ast_attribute_weight: clingo_ast_attribute_e = 43;
pub const clingo_ast_attribute_e_clingo_ast_attribute_comment_type: clingo_ast_attribute_e = 44;
#[doc = "! Enumeration of attributes used by the AST."]
pub type clingo_ast_attribute_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_attribute_e."]
pub type clingo_ast_attribute_t = ::std::os::raw::c_int;
#[doc = "! Struct to map attributes to their string representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_attribute_names {
    pub names: *const *const ::std::os::raw::c_char,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_attribute_names() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_ast_attribute_names> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_attribute_names>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_attribute_names))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_attribute_names>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_attribute_names))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_attribute_names),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_attribute_names),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct to map attributes to their string representation."]
pub type clingo_ast_attribute_names_t = clingo_ast_attribute_names;
extern "C" {
    #[doc = "! A map from attributes to their string representation."]
    pub static mut g_clingo_ast_attribute_names: clingo_ast_attribute_names_t;
}
#[doc = "! Struct to define an argument that consists of a name and a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_argument {
    pub attribute: clingo_ast_attribute_t,
    pub type_: clingo_ast_attribute_type_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_argument() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_ast_argument> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_argument>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_argument>(),
        4usize,
        concat!("Alignment of ", stringify!(clingo_ast_argument))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_argument),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_argument),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "! Struct to define an argument that consists of a name and a type."]
pub type clingo_ast_argument_t = clingo_ast_argument;
#[doc = "! A lists of required attributes to construct an AST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_constructor {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *const clingo_ast_argument_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_constructor() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_ast_constructor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_constructor>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_constructor))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_constructor>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_constructor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructor),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! A lists of required attributes to construct an AST."]
pub type clingo_ast_constructor_t = clingo_ast_constructor;
#[doc = "! Struct to map AST types to lists of required attributes to construct ASTs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_constructors {
    pub constructors: *const clingo_ast_constructor_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_constructors() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_ast_constructors> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_constructors>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_constructors))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_constructors>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_constructors))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructors),
            "::",
            stringify!(constructors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_constructors),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Struct to map AST types to lists of required attributes to construct ASTs."]
pub type clingo_ast_constructors_t = clingo_ast_constructors;
extern "C" {
    #[doc = "! A map from AST types to their constructors.\n!\n! @note The idea of this variable is to provide enough information to auto-generate code for language bindings."]
    pub static mut g_clingo_ast_constructors: clingo_ast_constructors_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast {
    _unused: [u8; 0],
}
#[doc = "! This struct provides a view to nodes in the AST."]
pub type clingo_ast_t = clingo_ast;
extern "C" {
    #[doc = "! Construct an AST of the given type.\n!\n! @note The arguments corresponding to the given type can be inspected using \"g_clingo_ast_constructors.constructors[type]\".\n!\n! @param[in] type the type of AST to construct\n! @param[out] ast the resulting AST\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if one of the arguments is incompatible with the type"]
    pub fn clingo_ast_build(type_: clingo_ast_type_t, ast: *mut *mut clingo_ast_t, ...) -> bool;
}
extern "C" {
    #[doc = "! Increment the reference count of an AST node.\n!\n! @note All functions that return AST nodes already increment the reference count.\n! The reference count of callback arguments is not incremented.\n!\n! @param[in] ast the target AST"]
    pub fn clingo_ast_acquire(ast: *mut clingo_ast_t);
}
extern "C" {
    #[doc = "! Decrement the reference count of an AST node.\n!\n! @note The node is deleted if the reference count reaches zero.\n!\n! @param[in] ast the target AST"]
    pub fn clingo_ast_release(ast: *mut clingo_ast_t);
}
extern "C" {
    #[doc = "! Create a shallow copy of an AST node.\n!\n! @param[in] ast the AST to copy\n! @param[out] copy the resulting AST\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_copy(ast: *mut clingo_ast_t, copy: *mut *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Create a deep copy of an AST node.\n!\n! @param[in] ast the AST to copy\n! @param[out] copy the resulting AST\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_deep_copy(ast: *mut clingo_ast_t, copy: *mut *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Less than compare two AST nodes.\n!\n! @param[in] a the left-hand-side AST\n! @param[in] b the right-hand-side AST\n! @return the result of the comparison"]
    pub fn clingo_ast_less_than(a: *mut clingo_ast_t, b: *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Equality compare two AST nodes.\n!\n! @param[in] a the left-hand-side AST\n! @param[in] b the right-hand-side AST\n! @return the result of the comparison"]
    pub fn clingo_ast_equal(a: *mut clingo_ast_t, b: *mut clingo_ast_t) -> bool;
}
extern "C" {
    #[doc = "! Compute a hash for an AST node.\n!\n! @param[in] ast the target AST\n! @return the resulting hash code"]
    pub fn clingo_ast_hash(ast: *mut clingo_ast_t) -> usize;
}
extern "C" {
    #[doc = "! Get the size of the string representation of an AST node.\n!\n! @param[in] ast the target AST\n! @param[out] size the size of the string representation\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_to_string_size(ast: *mut clingo_ast_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of an AST node.\n!\n! @param[in] ast the target AST\n! @param[out] string the string representation\n! @param[out] size the size of the string representation\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_to_string(
        ast: *mut clingo_ast_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of an AST node.\n!\n! @param[in] ast the target AST\n! @param[out] type the resulting type\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_get_type(ast: *mut clingo_ast_t, type_: *mut clingo_ast_type_t) -> bool;
}
extern "C" {
    #[doc = "! Check if an AST has the given attribute.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the attribute to check\n! @param[out] has_attribute the result\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_has_attribute(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        has_attribute: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of the given AST.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] type the resulting type\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_type(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        type_: *mut clingo_ast_attribute_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_number\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_number(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_number\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_number(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_symbol\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_symbol(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_symbol\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_symbol(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_location\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_location(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_location_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_location\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_location(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *const clingo_location_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_string\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_string(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_string\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_string(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_ast\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_ast\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_optional_ast\".\n!\n! @note The value might be \"NULL\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_optional_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_optional_ast\".\n!\n! @note The value might be \"NULL\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_set_optional_ast(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_set_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove an element from an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_delete_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an attribute of type \"clingo_ast_attribute_type_string_array\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_size_string_array(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Insert a value into an attribute of type \"clingo_ast_attribute_type_string_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_insert_string_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[out] value the resulting value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_get_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_set_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut clingo_ast_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Remove an element from an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_delete_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an attribute of type \"clingo_ast_attribute_type_ast_array\".\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[out] size the resulting size\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime"]
    pub fn clingo_ast_attribute_size_ast_array(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Insert a value into an attribute of type \"clingo_ast_attribute_type_ast_array\" at the given index.\n!\n! @param[in] ast the target AST\n! @param[in] attribute the target attribute\n! @param[in] index the target index\n! @param[in] value the value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_attribute_insert_ast_at(
        ast: *mut clingo_ast_t,
        attribute: clingo_ast_attribute_t,
        index: usize,
        value: *mut clingo_ast_t,
    ) -> bool;
}
#[doc = "! Callback function to intercept AST nodes.\n!\n! @param[in] ast the AST\n! @param[in] data a user data pointer\n! @return whether the call was successful"]
pub type clingo_ast_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ast: *mut clingo_ast_t, data: *mut ::std::os::raw::c_void) -> bool,
>;
extern "C" {
    #[doc = "! Parse the given program and return an abstract syntax tree for each statement via a callback.\n!\n! @note The control object can be set to a NULL to disable reading input in aspif format.\n!\n! @param[in] program the program in gringo syntax\n! @param[in] callback the callback reporting statements\n! @param[in] callback_data user data for the callback\n! @param[in] control object to add ground statements to\n! @param[in] logger callback to report messages during parsing\n! @param[in] logger_data user data for the logger\n! @param[in] message_limit the maximum number of times the logger is called\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if parsing fails\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_parse_string(
        program: *const ::std::os::raw::c_char,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
        control: *mut clingo_control_t,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = "! Parse the programs in the given list of files and return an abstract syntax tree for each statement via a callback.\n!\n! The function follows clingo's handling of files on the command line.\n! Filename \"-\" is treated as \"STDIN\" and if an empty list is given, then the parser will read from \"STDIN\".\n!\n! @note The control object can be set to a NULL to disable reading input in aspif format.\n!\n! @param[in] files the beginning of the file name array\n! @param[in] size the number of file names\n! @param[in] callback the callback reporting statements\n! @param[in] callback_data user data for the callback\n! @param[in] control object to add ground statements to\n! @param[in] logger callback to report messages during parsing\n! @param[in] logger_data user data for the logger\n! @param[in] message_limit the maximum number of times the logger is called\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if parsing fails\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_parse_files(
        files: *const *const ::std::os::raw::c_char,
        size: usize,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
        control: *mut clingo_control_t,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_program_builder {
    _unused: [u8; 0],
}
#[doc = "! Object to build non-ground programs."]
pub type clingo_program_builder_t = clingo_program_builder;
extern "C" {
    #[doc = "! Get an object to add non-ground directives to the program.\n!\n! See the @ref ProgramBuilder module for more information.\n!\n! @param[in] control the target\n! @param[out] builder the program builder object\n! @return whether the call was successful"]
    pub fn clingo_program_builder_init(
        control: *mut clingo_control_t,
        builder: *mut *mut clingo_program_builder_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Begin building a program.\n!\n! @param[in] builder the target program builder\n! @return whether the call was successful"]
    pub fn clingo_program_builder_begin(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    #[doc = "! End building a program.\n!\n! @param[in] builder the target program builder\n! @return whether the call was successful"]
    pub fn clingo_program_builder_end(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    #[doc = "! Adds a statement to the program.\n!\n! @attention @ref clingo_program_builder_begin() must be called before adding statements and @ref clingo_program_builder_end() must be called after all statements have been added.\n! @param[in] builder the target program builder\n! @param[in] ast the AST node to add\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime for statements of invalid form or AST nodes that do not represent statements\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_program_builder_add(
        builder: *mut clingo_program_builder_t,
        ast: *mut clingo_ast_t,
    ) -> bool;
}
#[doc = "!< To only unpool conditions of conditional literals."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_condition: clingo_ast_unpool_type_e = 1;
#[doc = "!< To unpool everything except conditions of conditional literals."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_other: clingo_ast_unpool_type_e = 2;
#[doc = "!< To unpool everything."]
pub const clingo_ast_unpool_type_e_clingo_ast_unpool_type_all: clingo_ast_unpool_type_e = 3;
#[doc = "! Enum to configure unpooling."]
pub type clingo_ast_unpool_type_e = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_ast_unpool_type_e."]
pub type clingo_ast_unpool_type_bitset_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Unpool the given AST.\n!\n! @param[in] ast the target AST\n! @param[in] unpool_type what to unpool\n! @param[in] callback the callback to report ASTs\n! @param[in] callback_data user data for the callback\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_ast_unpool(
        ast: *mut clingo_ast_t,
        unpool_type: clingo_ast_unpool_type_bitset_t,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_options {
    _unused: [u8; 0],
}
#[doc = "! Object to add command-line options."]
pub type clingo_options_t = clingo_options;
#[doc = "! Callback to customize clingo main function.\n!\n! @param[in] control corresponding control object\n! @param[in] files files passed via command line arguments\n! @param[in] size number of files\n! @param[in] data user data for the callback\n!\n! @return whether the call was successful"]
pub type clingo_main_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        control: *mut clingo_control_t,
        files: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Callback to print a model in default format.\n!\n! @param[in] data user data for the callback\n!\n! @return whether the call was successful"]
pub type clingo_default_model_printer_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
#[doc = "! Callback to customize model printing.\n!\n! @param[in] model the model\n! @param[in] printer the default model printer\n! @param[in] printer_data user data for the printer\n! @param[in] data user data for the callback\n!\n! @return whether the call was successful"]
pub type clingo_model_printer_t = ::std::option::Option<
    unsafe extern "C" fn(
        model: *const clingo_model_t,
        printer: clingo_default_model_printer_t,
        printer_data: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! This struct contains a set of functions to customize the clingo application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_application {
    #[doc = "!< callback to obtain program name"]
    pub program_name: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain version information"]
    pub version: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain message limit"]
    pub message_limit: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    >,
    #[doc = "!< callback to override clingo's main function"]
    pub main: clingo_main_function_t,
    #[doc = "!< callback to override default logger"]
    pub logger: clingo_logger_t,
    #[doc = "!< callback to override default model printing"]
    pub printer: clingo_model_printer_t,
    #[doc = "!< callback to register options"]
    pub register_options: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut clingo_options_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "!< callback validate options"]
    pub validate_options:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
}
#[test]
fn bindgen_test_layout_clingo_application() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_application> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_application>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_application))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_application>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_application))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).program_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(program_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_limit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(message_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logger) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(logger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).printer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(printer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_options) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(register_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validate_options) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(validate_options)
        )
    );
}
#[doc = "! This struct contains a set of functions to customize the clingo application."]
pub type clingo_application_t = clingo_application;
extern "C" {
    #[doc = "! Add an option that is processed with a custom parser.\n!\n! Note that the parser also has to take care of storing the semantic value of\n! the option somewhere.\n!\n! Parameter option specifies the name(s) of the option.\n! For example, \"ping,p\" adds the short option \"-p\" and its long form \"--ping\".\n! It is also possible to associate an option with a help level by adding \",@l\" to the option specification.\n! Options with a level greater than zero are only shown if the argument to help is greater or equal to l.\n!\n! @param[in] options object to register the option with\n! @param[in] group options are grouped into sections as given by this string\n! @param[in] option specifies the command line option\n! @param[in] description the description of the option\n! @param[in] parse callback to parse the value of the option\n! @param[in] data user data for the callback\n! @param[in] multi whether the option can appear multiple times on the command-line\n! @param[in] argument optional string to change the value name in the generated help output\n! @return whether the call was successful"]
    pub fn clingo_options_add(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                value: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
        multi: bool,
        argument: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an option that is a simple flag.\n!\n! This function is similar to @ref clingo_options_add() but simpler because it only supports flags, which do not have values.\n! If a flag is passed via the command-line the parameter target is set to true.\n!\n! @param[in] options object to register the option with\n! @param[in] group options are grouped into sections as given by this string\n! @param[in] option specifies the command line option\n! @param[in] description the description of the option\n! @param[in] target boolean set to true if the flag is given on the command-line\n! @return whether the call was successful"]
    pub fn clingo_options_add_flag(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        target: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Run clingo with a customized main function (similar to python and lua embedding).\n!\n! @param[in] application struct with callbacks to override default clingo functionality\n! @param[in] arguments command line arguments\n! @param[in] size number of arguments\n! @param[in] data user data to pass to callbacks in application\n! @return exit code to return from main function"]
    pub fn clingo_main(
        application: *mut clingo_application_t,
        arguments: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "! Custom scripting language to run functions during grounding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_script {
    #[doc = "! Evaluate the given source code.\n! @param[in] location the location in the logic program of the source code\n! @param[in] code the code to evaluate\n! @param[in] data user data as given when registering the script\n! @return whether the function call was successful"]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            location: *const clingo_location_t,
            code: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Call the function with the given name and arguments.\n! @param[in] location the location in the logic program of the function call\n! @param[in] name the name of the function\n! @param[in] arguments the arguments to the function\n! @param[in] arguments_size the number of arguments\n! @param[in] symbol_callback callback to return a pool of symbols\n! @param[in] symbol_callback_data user data for the symbol callback\n! @param[in] data user data as given when registering the script\n! @return whether the function call was successful"]
    pub call: ::std::option::Option<
        unsafe extern "C" fn(
            location: *const clingo_location_t,
            name: *const ::std::os::raw::c_char,
            arguments: *const clingo_symbol_t,
            arguments_size: usize,
            symbol_callback: clingo_symbol_callback_t,
            symbol_callback_data: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Check if the given function is callable.\n! @param[in] name the name of the function\n! @param[out] result whether the function is callable\n! @param[in] data user data as given when registering the script\n! @return whether the function call was successful"]
    pub callable: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            result: *mut bool,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Run the main function.\n! @param[in] control the control object to pass to the main function\n! @param[in] data user data as given when registering the script\n! @return whether the function call was successful"]
    pub main: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function is called once when the script is deleted.\n! @param[in] data user data as given when registering the script"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub version: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_script() {
    const UNINIT: ::std::mem::MaybeUninit<clingo_script> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clingo_script>(),
        48usize,
        concat!("Size of: ", stringify!(clingo_script))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_script>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_script))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(callable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_script),
            "::",
            stringify!(version)
        )
    );
}
#[doc = "! Custom scripting language to run functions during grounding."]
pub type clingo_script_t = clingo_script;
extern "C" {
    #[doc = "! Add a custom scripting language to clingo.\n!\n! @param[in] name the name of the scripting language\n! @param[in] script struct with functions implementing the language\n! @param[in] data user data to pass to callbacks in the script\n! @return whether the call was successful"]
    pub fn clingo_register_script(
        name: *const ::std::os::raw::c_char,
        script: *const clingo_script_t,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the version of the registered scripting language.\n!\n! @param[in] name the name of the scripting language\n! @return the version"]
    pub fn clingo_script_version(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
